<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=generator content="Source Themes Academic 4.8.0"><meta name=author content="Terry Tang"><meta name=description content="Amortized Analysis: Adding Things in Smart ways.
Lots of analyses get easier when you add things together after re-grouping them in smart ways.
Introduce Example: Think about an Algorithm from the Perspective of a Data Element&mldr; Example: Merge Sort"><link rel=alternate hreflang=en href=http://www.guozet.me/post/Algorim-Lecture-2/><meta name=theme-color content="#3f51b5"><script src=/js/mathjax-config.js></script><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.0-1/css/all.min.css integrity="sha256-4w9DunooKSr3MFXHXWyFER38WmPdm361bQS/2KUWZbU=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin=anonymous><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css crossorigin=anonymous title=hl-light><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css crossorigin=anonymous title=hl-dark disabled><script src=https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.1.2/lazysizes.min.js integrity="sha256-Md1qLToewPeKjfAHU1zyPwOutccPAm5tahnaw7Osw0A=" crossorigin=anonymous async></script><script src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js integrity crossorigin=anonymous async></script><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Montserrat:400,700%7CRoboto:400,400italic,700%7CRoboto+Mono&display=swap"><link rel=stylesheet href=/css/academic.css><link rel=manifest href=/index.webmanifest><link rel=icon type=image/png href=/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_32x32_fill_lanczos_center_3.png><link rel=apple-touch-icon type=image/png href=/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_192x192_fill_lanczos_center_3.png><link rel=canonical href=http://www.guozet.me/post/Algorim-Lecture-2/><meta property="twitter:card" content="summary"><meta property="og:site_name" content="Terry Tang"><meta property="og:url" content="http://www.guozet.me/post/Algorim-Lecture-2/"><meta property="og:title" content="Algorim Lecture 2-Amortized Analysis | Terry Tang"><meta property="og:description" content="Amortized Analysis: Adding Things in Smart ways.
Lots of analyses get easier when you add things together after re-grouping them in smart ways.
Introduce Example: Think about an Algorithm from the Perspective of a Data Element&mldr; Example: Merge Sort"><meta property="og:image" content="http://www.guozet.me/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png"><meta property="twitter:image" content="http://www.guozet.me/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png"><meta property="og:locale" content="en"><meta property="article:published_time" content="2019-01-15T14:47:20+00:00"><meta property="article:modified_time" content="2019-01-15T14:47:20+00:00"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://www.guozet.me/post/Algorim-Lecture-2/"},"headline":"Algorim Lecture 2-Amortized Analysis","datePublished":"2019-01-15T14:47:20Z","dateModified":"2019-01-15T14:47:20Z","author":{"@type":"Person","name":"Terry Tang"},"publisher":{"@type":"Organization","name":"Terry Tang","logo":{"@type":"ImageObject","url":"http://www.guozet.me/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_192x192_fill_lanczos_center_3.png"}},"description":"Amortized Analysis: Adding Things in Smart ways.\nLots of analyses get easier when you add things together after re-grouping them in smart ways.\nIntroduce Example: Think about an Algorithm from the Perspective of a Data Element\u0026hellip; Example: Merge Sort"}</script><title>Algorim Lecture 2-Amortized Analysis | Terry Tang</title></head><body id=top data-spy=scroll data-offset=70 data-target=#TableOfContents><aside class=search-results id=search><div class=container><section class=search-header><div class="row no-gutters justify-content-between mb-3"><div class=col-6><h1>Search</h1></div><div class="col-6 col-search-close"><a class=js-search href=#><i class="fas fa-times-circle text-muted" aria-hidden=true></i></a></div></div><div id=search-box><input name=q id=search-query placeholder=Search... autocapitalize=off autocomplete=off autocorrect=off spellcheck=false type=search></div></section><section class=section-search-results><div id=search-hits></div></section></div></aside><nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id=navbar-main><div class=container><div class="d-none d-lg-inline-flex"><a class=navbar-brand href=/>Terry Tang</a></div><button type=button class=navbar-toggler data-toggle=collapse data-target=#navbar-content aria-controls=navbar aria-expanded=false aria-label="Toggle navigation">
<span><i class="fas fa-bars"></i></span></button><div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none"><a class=navbar-brand href=/>Terry Tang</a></div><div class="navbar-collapse main-menu-item collapse justify-content-start" id=navbar-content><ul class="navbar-nav d-md-inline-flex"><li class=nav-item><a class="nav-link active" href=/post><span>Posts</span></a></li><li class=nav-item><a class=nav-link href=/#projects><span>Projects</span></a></li><li class=nav-item><a class=nav-link href=/#featured><span>Publications</span></a></li><li class=nav-item><a class=nav-link href=/courses/><span>Courses</span></a></li><li class=nav-item><a class=nav-link href=/leetcode><span>Leetcode</span></a></li><li class=nav-item><a class=nav-link href=/#contact><span>Contact</span></a></li></ul></div><ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2"><li class=nav-item><a class="nav-link js-search" href=#><i class="fas fa-search" aria-hidden=true></i></a></li><li class="nav-item dropdown theme-dropdown"><a href=# class="nav-link js-theme-selector" data-toggle=dropdown aria-haspopup=true><i class="fas fa-palette" aria-hidden=true></i></a><div class=dropdown-menu><a href=# class="dropdown-item js-set-theme-light"><span>Light</span>
</a><a href=# class="dropdown-item js-set-theme-dark"><span>Dark</span>
</a><a href=# class="dropdown-item js-set-theme-auto"><span>Automatic</span></a></div></li></ul></div></nav><article class=article><div class="article-container pt-3"><h1>Algorim Lecture 2-Amortized Analysis</h1><div class=article-metadata><span class=article-date>Jan 15, 2019
</span><span class=middot-divider></span>
<span class=article-reading-time>9 min read
</span><span class=middot-divider></span>
<a href=/post/Algorim-Lecture-2/#disqus_thread></a><span class=middot-divider></span>
<span class=article-categories><i class="fas fa-folder mr-1"></i></span></div></div><div class=article-container><div class=article-style><blockquote><p>Amortized Analysis: Adding Things in Smart ways.</p></blockquote><p>Lots of analyses get easier when you add things together after re-grouping them in smart ways.</p><h1 id=introduce>Introduce</h1><h2 id=example-think-about-an-algorithm-from-the-perspective-of-a-data-element>Example: Think about an Algorithm from the Perspective of a Data Element&mldr;</h2><p><strong>Example: Merge Sort</strong></p><p>It takes Θ(n) time to merge two sorted lists of conbined length n.</p><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-20-14-26-36.png alt></p><p>Think about the runtime level by level. Each level, the runtime is O(n). Each element have one time to merge.</p><p>If I am is one element, one element runtime is the O(logn).</p><p><strong>How much of work in the function for one element.</strong></p><ul><li><p>Figure out <code>how much work / running times is spent on a single generic element of data</code> during the course of the algorithm.</p></li><li><p>Add this up to get the total running time. (Compared to adding up the time spent on each &ldquo;operation&rdquo;, summed over each operation in chronological order)</p></li></ul><h2 id=example-enumerating-subsets>Example: Enumerating Subsets</h2><p>counter = 0</p><pre><code>For all subsets S ⊆ {1, 2, 3, 4 ... n}, 
  increment counter.
</code></pre><p>What is the value of counter at the end of execution?</p><blockquote><p>Counter = n*n</p></blockquote><p>Just two steps for each element, in the subset or not in the subset.</p><p>Think about the next one:</p><pre><code>For all subsets S ⊆ {1, 2, 3, 4 ... n}, 
  For all subsets T ⊆ S
    Increment Counter
</code></pre><p>Now, what is the value of counter at the end of execution?</p><p>If you thinking about the each subset, this is a confused way because some subsets are big and others are small. By this question, we can thing about the element by data.</p><p>So, each element can be in three ways: In S but not T, In S and T, not in S and T.</p><blockquote><p>Counter: n * n * n</p></blockquote><h2 id=example-domination-radius>Example: Domination Radius</h2><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-20-14-42-39.png alt></p><ul><li>Given the heights of N individuals standing in a line.</li><li>Goal: Find the domination radius of each individual.</li></ul><p>In this problem, each one will expand both left and right sides. Then, this solution need <code>n</code> expand time in the code. However, we want the solve this question in O(nlog n)</p><p><strong>Solution 1: Simple algorithm:</strong> from each element, scan left until blocked, then scan right until blocked.</p><blockquote><p>Running times: O($n^2$) worst-case</p></blockquote><p>There is an issue with this solution, if the element have been sorted and you go to the wrong way firstly, then you will get into trouble.</p><p><strong>Solution 2: Refinement-</strong> From each element, scan left and right simultaneously until blocked.</p><blockquote><p>Running times: O($n^2$) worst-case</p></blockquote><p>For each element in this array, they may have different worst time. The tallest one have the different worst time with the shortest one. The very tall people may spend a lot of works. and the lower one may only spend a few works. So, how we can get the worst-time for this solution, different element have the different worst-time in this case.
Their behaivir is totoally different.</p><p>High-Work: Scan $\geq$ D, So, total: O($ \frac{n}{D}*n $ )</p><p>Low-Work: Scan $\leq$ D (the work per element), So,total: O(n*D)</p><p>n is the # of the number of element in the array, so the worst work for each element is <code>n</code>. And How many elements for the high works: n/D because if the D is the each high-work element&rsquo;s interval. If the interval is less than D, then the scan > D is error. THe number of high element is n/D</p><p>From the above, the total running times: O($\frac{n^2}{D} + nD$), in this case, if we choose the D is with small, the first value will be very big. However, if we choose the D is very big, the second value will be very big even though the first value change to the small value. What is the best way we can get the best running times?</p><p>When the $D = \sqrt{n}$, we can get the best running times: O($n^{1.5} + n^{1.5}$) = O($2*n^{1.5}$)</p><p>In this case, if we have a sorted array:</p><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-17-15-15-41.png alt></p><p>The running times is:</p><p>$1 + 2 + 3 + &mldr; + n = \frac{n(n+1)}{2} = \Theta(n^2)$</p><p>Now, let&rsquo;s us to thing about how to build these element more than three groups.</p><table><thead><tr><th>Work/Element</th><th>Range</th><th>Max Number of Element</th><th>Total</th></tr></thead><tbody><tr><td>First Group</td><td>[n/2, n)</td><td>2 of them</td><td>O(n)</td></tr><tr><td>Second Group</td><td>[n/4, n/2)</td><td>4 of them</td><td>O(n)</td></tr><tr><td>Third Group</td><td>[n/8, n/4)</td><td>8 of them</td><td>O(n)</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td><td>&mldr;</td></tr></tbody></table><hr><p>So, in this case, we get the total times: O(nlog n)</p><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-20-14-24-12.png alt></p><hr><h1 id=re-sizing-memory-blocks>Re-Sizing Memory Blocks</h1><p>There are some questions for the Re-Sizing Memory Blocks:</p><ul><li>Since Memory blocks often cannot expand after allocation, what do we do when a memory block fills up?</li><li>For example, suppose we allocate 100 words of memory space for a stack (implemented as an array), but then realize we have more than 100 elements to push onto the stack!</li></ul><blockquote><p>Of course, if we use a linked list would have solved this problem, but suppose we really want to use arrays instead&mldr;)</p></blockquote><p><strong>Some exixt solution for this problem</strong></p><ol><li>A common technique for block expansion: Whenever our current block fills up, allocate a new block of twice its size and transfer the contents to the new block.</li><li>Unforturnaely, now some of our push operations will be quite slow!<ul><li>Most push operations take only O(1) time.</li><li>However, a push operation <strong>resulting in an expansion</strong> (and a copy of the n elements currently in the stack) will take $\Theta$(n) times.</li></ul></li></ol><p>So, what is the runtimes for the push.(It is hard to say.)</p><p>Push has a somewhat not-uniform running time profile:</p><ul><li>O(1) almost always</li><li>Except $\Theta$(N) every now and then.</li></ul><p>But just saying the running time is &ldquo;$\Theta$(N) in the worst case&rdquo; doesn&rsquo;t tell the whole story..</p><ul><li>Doesn&rsquo;t do the structure justive.</li><li>People might be scared to use it for large input sizes&mldr;</li></ul><p><strong>Most times, it is so fast.</strong> So, for these case, we need a new way to descript this case, it&rsquo;s bad to misunderstanding for the only past descript.</p><h2 id=how-much-does-each-push-actually-cost>How much does each push actually cost?</h2><h3 id=if-we-insert-the-element-in-the-stackarray>If we insert the element in the stack(array)</h3><p>And, what about if we charge ourselves 3 units of work per operation instead&mldr;?</p><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-20-14-43-23.png alt></p><p><strong>True</strong> cumulative cost after any sequence of k operations is upper bounded by <code>fictitious</code> cumulative cost of <code>3k</code>&mldr;</p><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-20-14-43-52.png alt></p><p>And, if we change something:</p><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-20-14-29-42.png alt></p><p>So, how different is our version of push from a version that takes 3 units in the worst case?</p><h2 id=amortized-analysis>Amortized Analysis</h2><p>Any sequence of k pushes takes O(k) worst-case time, so we say that push takes O(1) <strong>amortized time</strong>.</p><p><strong>On average</strong>, over the entire sequence, each individual push therefore takes O(1) time.</p><p>In general, an operation runs in O(f(n)) amortized time if any sequence of k such operations runs in O(k * f(n)) time.</p><h3 id=the-motivation-for-the-amortized-analysis>The motivation for the Amortized Analysis</h3><p>Amortized analysis is an ideal way to characterize the worst-case running time of operations with highly non-uniform performance.</p><p>It is still <code>worst-case</code> analysis, just averaged over an arbitrary sequence of operations. And, it gives us a much clearer picture of the true performance of a data structure that more faithfully describes the true performance. (For example, $\Theta(N)$ worst case vs. O(1) amortized.)</p><p><strong>Example</strong></p><p>Suppose we have 2 implementations of a data structure to choose from:</p><ul><li>O(log n) worst-case time / operation</li><li>O(log n) amortized time / operation</li></ul><blockquote><p>There is no difference if we use either A or B as part of <strong>a larger algorithm</strong>. For example, if our algorithm makes n calls to the data structure, the running time is O(n log n) in either case.</p></blockquote><p>The choice between A and B only matters in <strong>a &ldquo;real-time&rdquo; setting</strong> when the response time of an <strong>individual operation</strong> is important.</p><p>If the dataset is not big, you want to as fast as they can. Then choose the first one.</p><h3 id=generalizing-to-multiple-operations>Generalizing to Multiple operations</h3><p>We say an operation A requires O(f(n)) amortized time if any sequence of k invocations of A requires O(k f(n)) time in the worst case.</p><p>We say operations A and B have amortized running times of O($f_A(n)$) and O($f_B(n)$) if any sequence containing $K_A$ invocations of A and $K_B$ invocations of B requires: $O(K_A f_A(n) + K_B f_B(n))$. And so on, for 3 or more operations&mldr;</p><h3 id=a-simple-but-often-limited-method-for-amortized-analysis>A simple, but often limited, method for Amortized analysis</h3><p>Compute the worst-case running time for an arbitrary sequence of k operations, then divide by k. Unfortunately, it is often hard to bound the running time of an arbitrary sequence of k operations.(Especially if the operations are of several types &ndash; for example, &ldquo;push&rdquo; and &ldquo;pop&rdquo;)&mldr;</p><hr><h2 id=accounting-method-analysis>Accounting Method Analysis</h2><p><strong>Example Using Memory Re-Sizing</strong></p><p>Charge 3 units (i.e., O(1) amortized time) for each push operation.</p><ul><li>1 unit for the immediate push.</li><li>&ldquo;$2&rdquo; credit for future memory expansions.</li></ul><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-20-14-30-42.png alt></p><p>You charged upfront and use it later. Ans the dataset is not changed. Just make this quesiton like you pay for the car fees which we talked before.</p><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-20-14-33-04.png alt></p><p>There are the same thing, pay for the cost which you may be used in the future. The data you need pay for is not changed, just make each step siilar.</p><h3 id=what-about-adding-pop---will-this-work-well>What about adding &ldquo;Pop&rdquo; - Will this work well?</h3><p>When the buffer fills up due to too many pushes, double its size. And when the buffer becomes less than half full due to too many pops, halve its size. We want think about how to make the most space in the buffer are effective.</p><blockquote><p>If we use the half of the buffer as the line to detect double its size or half its size, this buffer may double and half frequently if these data size close with the half of buffer size.</p></blockquote><p>Change to When the buffer becomes less than one quarter full due to too many pops, halve its size. When the buffer fills up due to too many pushes, double its size.</p><h4 id=example-the-min-queue>Example: The Min-Queue</h4><p>Using either a linked list or a (circular) array, it is easy to implement a FIFO queue supporting the insert and delete operations both in O(1) worst-case time.</p><p>Suppose that we also want to support a find-min-operation, which returns the value of the minimum element currently present in the queue.<strong>It is possible to implement a &ldquo;min-queue&rdquo; supporting insert, delete, and find-min all in O(1) worst-case time?</strong></p><p>If we use a new structure about the Min-Queue as a Pair of &ldquo;Back-to-Back&rdquo; Min-Stacks.</p><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-20-16-33-05.png alt></p><p>We insert the data at the blue side, and delete the element at the yellow side. And, what will waste a lot of time in this case?</p><blockquote><p>When yellow stack becomes empty, spend O(n) time and transfer the contents of blue stack into the yellow stacks. Just like the blue stack pop and the yellow stack push the element in the stack.</p></blockquote><p><img src=/images/in-post/2019-01-15-Algorim-Lecture-2/2019-01-20-16-34-36.png alt></p></div><div class=article-tags><a class="badge badge-light" href=/tag/Node/>Node</a></div><div class=share-box aria-hidden=true><ul class=share><li><a href="https://twitter.com/intent/tweet?url=http://www.guozet.me/post/Algorim-Lecture-2/&amp;text=Algorim%20Lecture%202-Amortized%20Analysis" target=_blank rel=noopener class=share-btn-twitter><i class="fab fa-twitter"></i></a></li><li><a href="https://www.facebook.com/sharer.php?u=http://www.guozet.me/post/Algorim-Lecture-2/&amp;t=Algorim%20Lecture%202-Amortized%20Analysis" target=_blank rel=noopener class=share-btn-facebook><i class="fab fa-facebook"></i></a></li><li><a href="mailto:?subject=Algorim%20Lecture%202-Amortized%20Analysis&amp;body=http://www.guozet.me/post/Algorim-Lecture-2/" target=_blank rel=noopener class=share-btn-email><i class="fas fa-envelope"></i></a></li><li><a href="https://www.linkedin.com/shareArticle?url=http://www.guozet.me/post/Algorim-Lecture-2/&amp;title=Algorim%20Lecture%202-Amortized%20Analysis" target=_blank rel=noopener class=share-btn-linkedin><i class="fab fa-linkedin-in"></i></a></li><li><a href="https://web.whatsapp.com/send?text=Algorim%20Lecture%202-Amortized%20Analysis%20http://www.guozet.me/post/Algorim-Lecture-2/" target=_blank rel=noopener class=share-btn-whatsapp><i class="fab fa-whatsapp"></i></a></li><li><a href="https://service.weibo.com/share/share.php?url=http://www.guozet.me/post/Algorim-Lecture-2/&amp;title=Algorim%20Lecture%202-Amortized%20Analysis" target=_blank rel=noopener class=share-btn-weibo><i class="fab fa-weibo"></i></a></li></ul></div><div class="media author-card content-widget-hr"><img class="avatar mr-3 avatar-circle" src=/author/Terry-Tang/avatar_hu0d5a7b86078ca7c7d7d2e2c9e8f7e04b_578713_270x270_fill_q90_lanczos_center.jpg alt="Terry Tang"><div class=media-body><h5 class=card-title><a href=http://www.guozet.me/>Terry Tang</a></h5><h6 class=card-subtitle>SDE</h6><p class=card-text>My research interests include distributed robotics, mobile computing and programmable matter.</p><ul class=network-icon aria-hidden=true><li><a href=/#contact><i class="fas fa-envelope"></i></a></li><li><a href=https://github.com/guozetang target=_blank rel=noopener><i class="fab fa-github"></i></a></li><li><a href=https://www.facebook.com/guozetang target=_blank rel=noopener><i class="fab fa-facebook"></i></a></li><li><a href=https://www.linkedin.com/in/guoze/ target=_blank rel=noopener><i class="fab fa-linkedin"></i></a></li><li><a href=https://instagram.com/guozetang target=_blank rel=noopener><i class="fab fa-instagram"></i></a></li><li><a href=https://leetcode.com/guozetang/ target=_blank rel=noopener><i class="fas fa-laptop-code"></i></a></li><li><a href=/files/cv.pdf><i class="ai ai-cv"></i></a></li></ul></div></div><section id=comments><div id=disqus_thread></div><script>let disqus_config=function(){};(function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="https://guozet-me.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)})()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></section></div></article><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/languages/r.min.js></script><script>const code_highlighting=!0</script><script>const isSiteThemeDark=!1</script><script>const search_config={indexURI:"/index.json",minLength:1,threshold:.3},i18n={no_results:"No results found",placeholder:"Search...",results:"results found"},content_type={post:"Posts",project:"Projects",publication:"Publications",talk:"Talks"}</script><script id=search-hit-fuse-template type=text/x-template>
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script><script src=https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin=anonymous></script><script id=dsq-count-scr src=https://guozet-me.disqus.com/count.js async></script><script src=/js/academic.min.5cbe51271615d69caead0155ce0cb8ce.js></script><div class=container><footer class=site-footer><p class=powered-by>guozet.me © 2020</p><p class=powered-by>Powered by the
<a href=https://sourcethemes.com/academic/ target=_blank rel=noopener>Academic theme</a> for
<a href=https://gohugo.io target=_blank rel=noopener>Hugo</a>.
<span class=float-right aria-hidden=true><a href=# class=back-to-top><span class=button_icon><i class="fas fa-chevron-up fa-2x"></i></span></a></span></p></footer></div><div id=modal class="modal fade" role=dialog><div class=modal-dialog><div class=modal-content><div class=modal-header><h5 class=modal-title>Cite</h5><button type=button class=close data-dismiss=modal aria-label=Close>
<span aria-hidden=true>&#215;</span></button></div><div class=modal-body><pre><code class="tex hljs"></code></pre></div><div class=modal-footer><a class="btn btn-outline-primary my-1 js-copy-cite" href=# target=_blank><i class="fas fa-copy"></i> Copy
</a><a class="btn btn-outline-primary my-1 js-download-cite" href=# target=_blank><i class="fas fa-download"></i> Download</a><div id=modal-error></div></div></div></div></div></body></html>