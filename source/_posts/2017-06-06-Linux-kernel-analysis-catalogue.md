---
title: Linux内核分析课程_学习索引
date: 2015-06-14 13:04:27
categories: Linux
tags: Linux kernel
---
****
原创作品转载请注明出处.  
[《Linux内核分析》MOOC课程](http://mooc.study.163.com/course/USTC-1000029000)

# 一.学习目录索引  
Linux内核分析学习博客整理：   
[Linux内核分析课程1_计算机是如何工作的](http://blog.csdn.net/tang152453/article/details/44087589)  

> 计算机的工作过程，一言以蔽之：执行程序的过程；所以分析计算机的工作原理也就是分析计算机存储程序，执行程序的原理，所以，我们就需要先通过了解程序存储的这个过程。 
   
这篇博客主要分析了计算机的组成和计算机的工作原理，并例举C语言和汇编的转化，最后给出了程序执行时候堆栈变化的动态示意图。  
<!-- more -->

[Linux内核分析课程2_操作系统是如何工作的](http://blog.csdn.net/tang152453/article/details/44204925)
>操作系统的工作原理，可以说是计算机工作原理的第二部分：程序控制的过程，程序控制的体现有中断，系统调用，进程调度等。

博客中主要分析了操作系统的工作过程，用了一个时间中断函数来模拟了中断程序执行的过程，并给出了相应的堆栈变化示意图。

 [Linux内核分析课程3_start_kernel()函数分析](http://blog.csdn.net/tang152453/article/details/44536913)  
> start_kernel()这个函数是内核由引导程序引导以后，由自解压程序解压以后执行的第一个函数，可以认为是整个内核的入口函数，start_kernel()做的工作就是线性的初始化一些内核的基础机制，如中断，内存管理，进程管理，信号，文件系统，KO等！最后就启动一个init线程，init线程再读取文件系统里的init程序，做为系统的第一个进程而存在！  

博客中对linux启动过程中的start_kernel()函数进行分析，了解其主要的实现功能，在这里，主要对代码进行了解析。主要解析了：start_kernel() -> rest_init() -> kernel_init() -> 启动init进程。  

[Linux内核分析课程4_Linux系统调用](http://blog.csdn.net/tang152453/article/details/44726799)  
> 系统调用，顾名思义，说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置定时器等。  

> 从逻辑上来说，系统调用可被看成是一个内核与用户空间程序交互的接口——它好比一个中间人，把用户进程的请求传达给内核，待内核把请求处理完毕后再将处理结果送回给用户空间。  

博客中详细的分析了系统调用的原理，实现方式和意义；API，系统调用，系统命令，内核函数之间的区别，最后分别用C语言和汇编来实现了exit系统调用。

[Linux内核分析课程5_system_call中断处理过程](http://blog.csdn.net/tang152453/article/details/44888515)  
> 系统调用流程介绍：  
> 1. 执行用户程序(如:fork,exit)  
> 2. 根据glibc中的函数实现，取得系统调用号并执行int $0x80产生中断。  
> 3. 进行地址空间的转换和堆栈的切换，执行SAVE_ALL。（进行内核模式）
> 4. 进行中断处理，根据系统调用表调用内核函数。
> 5. 执行内核函数。
> 6. 执行RESTORE_ALL并返回用户模式  
 本文中使用gdb调试了sys_exit系统调用，并对系统调用的源代码进行了详细的分析。  

[Linux内核分析课程6_进程创建](http://blog.csdn.net/tang152453/article/details/45011085)  

> 在 Linux 内核中,供用户创建进程的系统调用fork()函数的响应函数是 sys_fork()、sys_clone()、sys_vfork()。这三个函数都是通过调用内核函数 do_fork() 来实现的。  
　　

本篇博客详细分析了进程创建过程(fork())的详细执行过程。
　　

[Linux内核分析课程7_execve()函数对应的系统调用处理过程](http://blog.csdn.net/tang152453/article/details/45126661)  

> 昔者庄周梦为蝴蝶，栩栩然蝴蝶也，自喻适志与，不知周也。俄然觉，则蘧蘧然周也。不知周之梦为蝴蝶与，蝴蝶之梦为周与？周与蝴蝶，则必有分矣。此之谓物化。（《庄子·齐物论》）   
> 在我们的操作系统中,也有如此浪漫情怀的庄生梦蝶—–exec()函数族.   
> 博客中中对exec()函数族进行了介绍，之后对do_execve()函数进行了分析。  
>
　　
{% post_link Linux-kernel-analysis-task-management %}  
> 进程调度中schedule()函数选择一个新的进程来运行，并调用context_switch进行上下文的切换，这个宏调用switch_to来进行关键上下文切换。  
主要调用过程：   
　　　　next = pick_next_task(rq, prev);//进程调度算法都封装这个函数内部   
　　　　context_switch(rq, prev, next);//进程上下文切换   
　　　　switch_to利用了prev和next两个参数：prev指向当前进程，next指向被调度的进程  

博客中对schedule函数进行了相关介绍，以及分析了schedule函数的内核实现的详细流程。

****
# 二.学习心得
## 对Linux系统的认识
很幸运参加了这为期两个月的MOOC课程《Linux内核分析》，让我对Linux系统有了更深的认识。  
> Linux系统的开源思想是最值得我们学习的，开源的思想也会成为我们软件行业的主导的。   
> Linux系统最为核心也就是进程调度，中断处理，时钟和文件系统，我们只要对这几个方面了解到了，也就了解了Linux系统的关键了。

## 学习Linux内核的心得
学习Linux内核的过程也半年多了，从嵌入式系统设计中的ucos初步认识操作系统(核心：进程调度)，嵌入式操作系统中的（ARM中的Linux）再到Linux内核分析(x86体系下)，一步一步的深入，在这个过程中，有几本书对我影响很多，给大家推荐一下:   

《Linux内核设计与实现》，想学习linux内核就要先了解相应的机制之后再去看源代码的话，可能会收获到更多，而这本书介绍了诸如进程管理、系统调用、中断和中断处理程序、内核同步、时间管理、内存管理、地址空间、调试技术等方面，内容比较浅显易懂，比较适合学习Linux内核的新人.

之后就不得不提到《深入理解Linux内核》这本书了，这本最好是能深入学习。简而言之，第一本，提纲性阅读；第二本，适合深入阅读。

当然，纸上得来终觉浅，绝知此事要躬行；在书本学习的基础上，需要我们利用好gdb这个调试工具，多跟踪一下内核的一些机制的执行流程，在实践中验证知识，才能更好的掌握知识。

