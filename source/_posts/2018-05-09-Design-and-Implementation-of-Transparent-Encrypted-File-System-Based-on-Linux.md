---
title: 基于Linux透明加密文件系统的设计与实现
date: 2018-05-07 13:04:27
categories: Linux
tags: Linux kernel
---

基于Linux透明加密文件系统的设计与实现
=========
# 选题背景
现在人们对计算机系统安全问题考虑的越来越多，对计算机系统安全的要求也越来越严格，数据安全早已不在是军方和政府要害部门的特殊需求。现在，几乎所有的应用领域包括银行、电子交易、政府、互联网络、专用网络和企业内部网络都有数据安全的需求。与此同时个人计算机的数据泄密问题也日益突出。加密技术在现代计算机系统安全中扮演着越来越重要的角色。而加密文件系统是加密技术中比较成熟和通用的方式。
<!-- more -->
# 需求分析
对几种现有典型加密文件系统分析，我们可以发现传统的加密文件系统都存在着不同程度的问题，主要集中在这几个方面：数据的保护不完全；性能低下；密钥管理机制不够完善；界面交互性差；透明度差。
- 针对用户：普通Ubuntu等Linux系统个人用户者
-	用户特点：对命令行操作并不是很熟悉

# 设计目标
集合需求分析，我们的设计目标是：
- 对系统的运算速度不能产生太大的影响；
- 整个加解密过程对用户而言是透明的，授权访问者可以很直观的读取文件明文，而非授权访问者读取到的都是已经加密过后的密文；
- 在相似的操作系统中能够很好的进行移植。  

根据这些需求，并结合现有加密文件系统的分析，我们选用堆叠式文件系统的方式来实现。设计的系统框架如下: 
![18_05_Linux文件加密系统框架示意图](/images/in-post/18_05_Linux文件加密系统框架示意图.png) 

# 系统简介
系统的主体功能是通过堆叠式文件系统来实现本地数据的加解密工作，具体需要实现的有：
- 加密文件系统开发，以一个独立的内核模块进行部署；
- 用户操作界面的开发，对用户更友好；
- 用户认证机制和文件加密密码验证结合，提高安全性；
- 除了正文，也可以对文件名加密；
- 用户可以自由选择下层文件系统来存放加密文件。  

## 系统框架
### Read操作
当用户发起read操作，加密文件系统中相关函数就被VFS中的系统调用sys_read()调用来处理这一个请求，他必须首先调用下层文件系统的read()以读取加密过的文件数据，然后解密文件数据，最后将解密后的原数据返回给用户。
![18_05_Linux透明加密文件系统Read操作](/images/in-post/18_05_Linux透明加密文件系统Read操作.png) 

write操作
用户进程的write()函数经过系统通用的VFS层，就转化成了系统调用sys_write()；VFS层的系统调用sys_write()函数再调用堆叠式加密文件系统中的encrypt_write()函数，然后compressfs_write()函数对上层用户空间传来的数据进行加密；之后再调用位于加密文件系统下层的具体文件系统中write()函数；将加密后的数据写入底层的具体文件系统当中去。
![18_05_Linux透明加密文件系统Write操作](/images/in-post/18_05_Linux透明加密文件系统Write操作.png) 

### 文件系统详细结构图
![18_05_09_Linux透明加密文件系统详细结构示意图](/images/in-post/18_05_09_Linux透明加密文件系统详细结构示意图.png) 

### 秘钥管理
![18_05_09_Linux透明加密文件系统秘钥管理示意图](/images/in-post/18_05_09_Linux透明加密文件系统秘钥管理示意图.png) 

# 成果展示
## 工作流程
![18_05_09_Linux透明加密文件系统工作流程示意图](/images/in-post/18_05_09_Linux透明加密文件系统工作流程示意图.png) 
## 用户操作界面
### 用户加解密操作
![18_05_09_Linux用户操作之加解密图形界面](/images/in-post/18_05_09_Linux用户操作之加解密图形界面.png) 
### 文件挂载后的操作界面
![18_05_09_文件系统挂载后操作界面](/images/in-post/18_05_09_文件系统挂载后操作界面.png) 

# 技术难点
## 加密文件系统实现方式选择（三种选择）
- 基于应用层来实现文件的加解密；
- 修改现有文件系统来实现；
- 堆叠式文件系统。  

综合用户需求我们选择的是第三种方案，用堆叠式文件系统来实现透明加密。

## 加密位置的选择
加密文件系统实现的难点之一在于找到一个Linux核心代码中合适的位置进行加解密操作。加密位置选择得好，便于实现，而且对系统的性能影响要比较小。我们选择的原则就是尽可能的将加解密操作延后。对于写操作，只在实际写入磁盘的时候才进行加密，对于读操作，只有在接近送到用户空间的缓冲区的时候才进行解密，加密的位置要让数据在Buffer Cache中是以明文形式存在的，以便能够利用Linux的缓冲机制提高加密文件系统的性能。反之，假设我们在Linux Buffer Cache层以上进行加解密操作，这就意味着对于加密的文件，Buffer Cache中存在的是密文，每次内核需要Buffer Cache中的内容的时候都要先进行加解密的工作，这将会大大的降低系统的性能。

## 交互式脚本书写
如何书写与文件系统运行时候的交互式脚本，实现加密文件系统的自动化挂载过程。

![18_05_09_文件系统交互式脚本书写](/images/in-post/18_05_09_文件系统交互式脚本书写.png)   

## QT与Shell脚本交互
如何将QT图形界面获取到的参数传递给脚本，并启动脚本，如何返回脚本的执行情况给图形化界面。

![18_05_09_QT与Shell脚本交互示意图](/images/in-post/18_05_09_QT与Shell脚本交互示意图.png) 
