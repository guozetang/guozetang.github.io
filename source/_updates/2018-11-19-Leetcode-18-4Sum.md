---
title: Leetcode 169. Majority Element
date: 2018-11-19 06:09:31
updated: 2018-11-19 06:09:31
categories: Leetcode
tags: Leetcode
notshow: true
top:
---

# Question

Given an array  `nums`  of  _n_  integers and an integer  `target`, are there elements  _a_,  _b_,  _c_, and  _d_  in  `nums`  such that  _a_  +  _b_  +  _c_  +  _d_  =  `target`? Find all unique quadruplets in the array which gives the sum of  `target`.

**Note:**

The solution set must not contain duplicate quadruplets.

**Example:**

> Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.
> A solution set is:
> [
>  [-1,  0, 0, 1],
>  [-2, -1, 1, 2],
>  [-2,  0, 0, 2]
> ]

**Difficulty**:Medium
**Category**:Array, Hash Table, Two Points.

<!-- more -->

------------

# Analyze

方案一： 对数组进行排序，然后固定两个值，寻找另外两个数值，左右夹逼的方式，这种情况的时间复杂度是`O(n^3)`

方案二： 

------------

# Solution

**Solution 1（方案一）:先排序固定两个数值，然后夹逼的方式**

```cpp
class Solution {
 public:
  vector<vector<int>> fourSum(vector<int> &nums, int target) {
    set<vector<int>> res;
    sort(nums.begin(), nums.end());

    for (int i = 0; i < int(nums.size() - 3); ++i) {
      for (int j = i + 1; j < int(nums.size() - 2); ++j) {
        if (j > i + 1 && nums[j] == nums[j - 1]) continue;
        int left = j + 1, right = nums.size() - 1;

        while (left < right) {
          int sum = nums[i] + nums[j] + nums[left] + nums[right];
          if (sum == target) {
            vector<int> out{nums[i], nums[j], nums[left], nums[right]};
            res.insert(out);
            ++left;
            --right;
          } else if (sum < target)
            ++left;
          else
            --right;
        }
      }
    }
    return vector<vector<int>>(res.begin(), res.end());
  }
};
```


------------
