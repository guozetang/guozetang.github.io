<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Terry Tang</title>
  
  <subtitle>Terry Blog &amp; 唐国泽的博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-10T16:49:36.966Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Terry Tang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Object Object]</title>
    <link href="http://yoursite.com//blog/2018/05/10/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1.html"/>
    <id>http://yoursite.com//blog/2018/05/10/Linux文件系统设计.html</id>
    <published>2018-05-10T16:49:36.962Z</published>
    <updated>2018-05-10T16:49:36.966Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[Object Object]</title>
    <link href="http://yoursite.com//blog/2018/05/10/Test4.html"/>
    <id>http://yoursite.com//blog/2018/05/10/Test4.html</id>
    <published>2018-05-10T16:39:27.937Z</published>
    <updated>2018-05-10T16:39:27.939Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[Object Object]</title>
    <link href="http://yoursite.com//blog/2018/05/10/Test3.html"/>
    <id>http://yoursite.com//blog/2018/05/10/Test3.html</id>
    <published>2018-05-10T16:38:31.773Z</published>
    <updated>2018-05-10T16:38:31.776Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[Object Object]</title>
    <link href="http://yoursite.com//blog/2018/05/10/Test2.html"/>
    <id>http://yoursite.com//blog/2018/05/10/Test2.html</id>
    <published>2018-05-10T16:23:27.344Z</published>
    <updated>2018-05-10T16:23:27.347Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[Object Object]</title>
    <link href="http://yoursite.com//blog/2018/05/10/Use-Hexo-Next-build-Blog-on-Github.html"/>
    <id>http://yoursite.com//blog/2018/05/10/Use-Hexo-Next-build-Blog-on-Github.html</id>
    <published>2018-05-10T16:22:42.375Z</published>
    <updated>2018-05-10T16:22:42.377Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[Object Object]</title>
    <link href="http://yoursite.com//blog/2018/05/10/%E2%80%9CHexo-Next-Github-Blog%E2%80%9D.html"/>
    <id>http://yoursite.com//blog/2018/05/10/“Hexo-Next-Github-Blog”.html</id>
    <published>2018-05-10T16:20:34.716Z</published>
    <updated>2018-05-10T16:20:34.718Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>[Object Object]</title>
    <link href="http://yoursite.com//blog/2018/05/10/Linux%E9%80%8F%E6%98%8E%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F1_%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90.html"/>
    <id>http://yoursite.com//blog/2018/05/10/Linux透明加密文件系统1_代码分析.html</id>
    <published>2018-05-10T04:57:49.303Z</published>
    <updated>2018-05-10T17:00:14.746Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Linux透明加密文件系统代码分析"><a href="#Linux透明加密文件系统代码分析" class="headerlink" title="Linux透明加密文件系统代码分析"></a>Linux透明加密文件系统代码分析</h1><p>主要分为三个部分：</p><blockquote><p>第一部分是交互脚本与自动化脚本(Ubuntu)<br>第二部分是界面设计<br>第三部分是开源项目代码的说明  </p></blockquote><p>用户使用的是基于QT的用户界面，可以选择需要加密的文件路径，已经加密之后的路径。当图形界面接收到这些信息之后，会将该信息转换成一段包含了8个参数的数据包传递给shell脚本进行处理。</p><h2 id="一-交互脚本与自动化脚本"><a href="#一-交互脚本与自动化脚本" class="headerlink" title="一.交互脚本与自动化脚本"></a>一.交互脚本与自动化脚本</h2><h3 id="1-处理交互式过程的脚本"><a href="#1-处理交互式过程的脚本" class="headerlink" title="1. 处理交互式过程的脚本"></a>1. 处理交互式过程的脚本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/expect</span></span><br><span class="line"><span class="comment">#该文件是处理交互式过程的主要文件，用来对输出信息进行解析，并自动输入对应的信息</span></span><br><span class="line"><span class="built_in">set</span> timeout 2</span><br><span class="line"><span class="built_in">set</span> ecryptfs_real [lindex <span class="variable">$argv</span> 0]</span><br><span class="line"><span class="comment">#真实文件路径,实际的加密文件位置</span></span><br><span class="line"><span class="built_in">set</span> ecryptfs_mount [lindex <span class="variable">$argv</span> 1]</span><br><span class="line"><span class="comment">#挂载点路径，解密文件的位置</span></span><br><span class="line"><span class="built_in">set</span> tangpassword [lindex <span class="variable">$argv</span> 2]</span><br><span class="line"><span class="comment">#用户密码</span></span><br><span class="line"><span class="built_in">set</span> key_type1 [lindex <span class="variable">$argv</span> 3]</span><br><span class="line"> <span class="comment">#密码管理方式</span></span><br><span class="line"><span class="built_in">set</span> Passphrase [lindex <span class="variable">$argv</span> 4]</span><br><span class="line"> <span class="comment">#文件加密密码</span></span><br><span class="line"><span class="built_in">set</span> ecryptfs_type [lindex <span class="variable">$argv</span> 5]</span><br><span class="line"><span class="comment">#文件加密类型</span></span><br><span class="line"><span class="built_in">set</span> key_bytes [lindex <span class="variable">$argv</span> 6]</span><br><span class="line"><span class="comment">#文件加密位数</span></span><br><span class="line"><span class="built_in">set</span> ecryptfs_fspath [lindex <span class="variable">$argv</span> 7]</span><br><span class="line"><span class="comment">#路径是否加密</span></span><br><span class="line"><span class="built_in">set</span> ecryptfs_filename [lindex <span class="variable">$argv</span> 8]</span><br><span class="line"><span class="comment">#文件名是否加密</span></span><br><span class="line">spawn sudo mount -t ecryptfs <span class="variable">$ecryptfs_real</span> <span class="variable">$ecryptfs_mount</span><span class="comment">#挂载加密文件系统</span></span><br><span class="line">expect <span class="string">"password for tang:"</span></span><br><span class="line">send <span class="string">"<span class="variable">$tangpassword</span>\n"</span></span><br><span class="line"><span class="comment">#填充用户密码</span></span><br><span class="line">expect <span class="string">"Select key type to use for newly created files:"</span></span><br><span class="line">send <span class="string">"<span class="variable">$key_type1</span>\n"</span></span><br><span class="line">expect</span><br><span class="line"><span class="comment">#填充加密方式类型 "Passphrase:"</span></span><br><span class="line">send <span class="string">"<span class="variable">$Passphrase</span>\n"</span></span><br><span class="line"><span class="comment">#填充文件加密密码</span></span><br><span class="line">expect <span class="string">"aes"</span></span><br><span class="line">send <span class="string">"<span class="variable">$ecryptfs_type</span>\n"</span></span><br><span class="line"><span class="comment">#填充文件加密类型</span></span><br><span class="line">expect <span class="string">"Select key bytes:"</span></span><br><span class="line">send <span class="string">"<span class="variable">$key_bytes</span>\n"</span></span><br><span class="line"><span class="comment">#填写文件加密位数</span></span><br><span class="line">expect <span class="string">"Enable plaintext passthrough"</span></span><br><span class="line">send <span class="string">"<span class="variable">$ecryptfs_fspath</span>\n"</span></span><br><span class="line"><span class="comment">#选择是否对路径加密</span></span><br><span class="line">expect <span class="string">"Enable filename encryption"</span></span><br><span class="line">send <span class="string">"<span class="variable">$ecryptfs_filename</span>\r"</span></span><br><span class="line">interact</span><br><span class="line"><span class="comment">#选择是否对文件名加密</span></span><br><span class="line"><span class="comment">#expect eof</span></span><br><span class="line"><span class="comment">#exit</span></span><br></pre></td></tr></table></figure><h3 id="2-与QT交互的脚本"><a href="#2-与QT交互的脚本" class="headerlink" title="2. 与QT交互的脚本"></a>2. 与QT交互的脚本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">##该脚本主要作用是接收QT传递过来的变量，并进行解析，之后，调用相应的交互处理脚本##接收QT传递过来的变量</span></span><br><span class="line">ECRYPTFS_REAL=<span class="variable">$1</span>                <span class="comment">##获取加密路径</span></span><br><span class="line">PASSWD=<span class="variable">$2</span><span class="comment">##用户密码</span></span><br><span class="line">PASS_TYPE=<span class="variable">$3</span><span class="comment">##密码类型</span></span><br><span class="line">PASSPHRASE=<span class="variable">$4</span><span class="comment">##加密路径，挂载点</span></span><br><span class="line">ECRYPTFS_TYPE=<span class="variable">$5</span>                <span class="comment">##加密类型</span></span><br><span class="line">ECRYPTFS_BIT=<span class="variable">$6</span><span class="comment">##加密位数</span></span><br><span class="line">ECRYPTFS_FS=<span class="variable">$7</span><span class="comment">##路径是否加密</span></span><br><span class="line">ECRYPTFS_FILENAME=<span class="variable">$8</span>         <span class="comment">##文件名是否加密</span></span><br><span class="line">count=0   <span class="comment">##初始值</span></span><br><span class="line">dir=<span class="string">"/tmp/mnt/ecryptfs<span class="variable">$count</span>"</span> <span class="comment">##初始挂载点</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"Ecryptfs加密程序启动中..."</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"申请超级用户权限,请输入用户密码"</span></span><br><span class="line"><span class="comment">##/bin/testpass</span></span><br><span class="line">df 1&gt;/tmp/1.txt 2&gt;/dev/null</span><br><span class="line"><span class="comment">##检测当前已经使用的挂载点，建立一个新的挂载点来使用</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"已经挂载的加密目录有："</span></span><br><span class="line"> <span class="keyword">while</span> cat /tmp/1.txt | grep -q <span class="variable">$dir</span> 2&gt;/dev/null</span><br><span class="line">   <span class="comment">##挂载点 是否使用了</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$dir</span></span><br><span class="line"><span class="built_in">let</span> count=<span class="variable">$count</span>+1 <span class="comment">##一定要是/bin/bash如是/bin/sh这里就会出错</span></span><br><span class="line">dir=<span class="string">"/tmp/mnt/ecryptfs<span class="variable">$count</span>"</span>  <span class="comment">###新挂载点</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">rm /tmp/1.txt</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"新增挂载目录："</span> <span class="comment">###创建新的挂载点</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$dir</span> ];<span class="keyword">then</span> <span class="comment">##判断目录是否存在</span></span><br><span class="line">mkdir -p <span class="variable">$dir</span> <span class="comment">###建立新挂载点目录,选项p，可以创建连续文件夹</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"加密程序启动，开始加密……</span></span><br><span class="line"><span class="string"> echo "</span>请输入加密密码，选择加密方式：<span class="string">"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## sudo mount -t ecryptfs <span class="variable">$(pwd)</span> <span class="variable">$dir</span>  ### <span class="variable">$( )</span>为引用命令结果</span></span><br><span class="line"><span class="string">##调用交互脚本来处理和用户的交互过程</span></span><br><span class="line"><span class="string">echo <span class="variable">$ECRYPTFS_REAL</span> <span class="variable">$dir</span> <span class="variable">$PASSWD</span> <span class="variable">$ECRYPTFS_TYPE</span> <span class="variable">$ECRYPTFS_BIT</span> <span class="variable">$ECRYPTFS_FS</span> <span class="variable">$ECRYPTFS_FILENAME</span></span></span><br><span class="line"><span class="string">   /bin/automount <span class="variable">$ECRYPTFS_REAL</span> <span class="variable">$dir</span> <span class="variable">$PASSWD</span> <span class="variable">$PASS_TYPE</span> <span class="variable">$PASSPHRASE</span> <span class="variable">$ECRYPTFS_TYPE</span> <span class="variable">$ECRYPTFS_BIT</span> <span class="variable">$ECRYPTFS_FS</span> <span class="variable">$ECRYPTFS_FILENAME</span></span></span><br></pre></td></tr></table></figure><h3 id="3-挂载点操作脚本"><a href="#3-挂载点操作脚本" class="headerlink" title="3. 挂载点操作脚本"></a>3. 挂载点操作脚本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">##用来对当前挂载点进行卸载删除</span></span><br><span class="line">count=0</span><br><span class="line">dir=<span class="string">"/tmp/mnt/ecryptfs<span class="variable">$count</span>"</span></span><br><span class="line">gksudo df 1&gt;/tmp/1.txt</span><br><span class="line"><span class="keyword">while</span> cat /tmp/1.txt |grep -q <span class="variable">$dir</span> 2&gt;/dev/null<span class="comment">##检查现在存在的挂载</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$dir</span></span><br><span class="line"><span class="built_in">let</span> count=<span class="variable">$count</span>+1</span><br><span class="line">sudo umount <span class="variable">$dir</span> &amp;&amp; rmdir <span class="variable">$dir</span>　　<span class="comment">##卸载挂载点，卸载成功的前提下删除挂载点</span></span><br><span class="line">dir=<span class="string">"/tmp/mnt/ecryptfs<span class="variable">$count</span>"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h3 id="4-添加到鼠标右键菜单的执行脚本"><a href="#4-添加到鼠标右键菜单的执行脚本" class="headerlink" title="4. 添加到鼠标右键菜单的执行脚本"></a>4. 添加到鼠标右键菜单的执行脚本</h3> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">##添加到右键的执行脚本，用来打开QT交互式界面，获取用户的输入信息</span></span><br><span class="line">/home/tang/ecryptfs/imageconverter</span><br><span class="line"><span class="comment">#/bin/ecryptfs_mounted.sh&amp;</span></span><br></pre></td></tr></table></figure><h3 id="5-在QT调用执行挂载脚本"><a href="#5-在QT调用执行挂载脚本" class="headerlink" title="5. 在QT调用执行挂载脚本"></a>5. 在QT调用执行挂载脚本</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="comment">##在QT中调用该脚本，该脚本的主要功能是执行挂载脚本ecryptfs_mounted.sh</span></span><br><span class="line">REALFILE=<span class="variable">$1</span></span><br><span class="line">ECRYPTFSPATH=<span class="string">"/bin/ecryptfs_mounted.sh <span class="variable">$REALFILE</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$REALFILE</span> 1&gt;/TMP/2.txt</span><br><span class="line"><span class="built_in">echo</span></span><br><span class="line"><span class="variable">$ECRYPTFSPATH</span> 1&gt;&gt;/tmp/2.txt</span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line"><span class="variable">$ECRYPTFSPATH</span></span><br><span class="line"><span class="comment">#exec gnome-terminal -x</span></span><br><span class="line"><span class="variable">$ECRYPTFSPATH</span></span><br><span class="line"><span class="comment">#/bin/ecryptfs_mounted.sh&amp;</span></span><br></pre></td></tr></table></figure><h2 id="二-QT界面程序设计"><a href="#二-QT界面程序设计" class="headerlink" title="二. ＱＴ界面程序设计"></a>二. ＱＴ界面程序设计</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;QtGui&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"convertdialog.h"</span></span></span><br><span class="line"></span><br><span class="line">ConvertDialog::ConvertDialog(QWidget *parent)</span><br><span class="line">    : QDialog(parent)</span><br><span class="line">&#123;</span><br><span class="line">    setupUi(<span class="keyword">this</span>);      <span class="comment">//创建并布局好所有的窗口部件</span></span><br><span class="line">     passwordEdit-&gt;setEchoMode (QLineEdit::Password);<span class="comment">//用户口令输入框</span></span><br><span class="line">    filepasswordEdit-&gt;setEchoMode (QLineEdit::Password);<span class="comment">//文件密码输入框</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ConvertDialog::on_browseButton_clicked()<span class="comment">//选择路径按钮触发</span></span><br><span class="line">&#123;</span><br><span class="line">    QString initialName = sourceFileEdit-&gt;text();<span class="comment">//加密文件夹路径输入框</span></span><br><span class="line">    <span class="keyword">if</span> (initialName.isEmpty())</span><br><span class="line">        initialName = QDir::homePath();<span class="comment">//为空，使用默认路径</span></span><br><span class="line">    QString fileName =</span><br><span class="line">            QFileDialog::getExistingDirectory(<span class="keyword">this</span>, tr(<span class="string">"Choose File"</span>),</span><br><span class="line">                                         initialName);<span class="comment">//弹出计算机路径选择框，选择路径加密</span></span><br><span class="line">    fileName = QDir::toNativeSeparators(fileName);<span class="comment">//加密路径</span></span><br><span class="line">    <span class="keyword">if</span> (!fileName.isEmpty()) &#123;</span><br><span class="line">        sourceFileEdit-&gt;setText(fileName);<span class="comment">//将路径信息保存起来</span></span><br><span class="line">       <span class="comment">// buttonBox-&gt;button(QDialogButtonBox::Ok)-&gt;setEnabled(true);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ConvertDialog::on_passwordEdit_textEdited(<span class="keyword">const</span> QString &amp;arg1)<span class="comment">//password密码框</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QRegExp <span class="title">regx</span> <span class="params">(<span class="string">"^[^ ]+$"</span>)</span></span>;<span class="comment">// 设定正则表达式，不能输入空格</span></span><br><span class="line">    QValidator *validator=<span class="keyword">new</span> QRegExpValidator(regx,<span class="keyword">this</span>);</span><br><span class="line">    passwordEdit-&gt;setValidator(validator);</span><br><span class="line">    filepasswordEdit-&gt;setValidator(validator);<span class="comment">//正则表达式控制输入框字符格式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ConvertDialog::on_filepasswordEdit_textEdited(<span class="keyword">const</span> QString &amp;arg1)<span class="comment">//filepassword密码框</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">QRegExp <span class="title">regx</span> <span class="params">(<span class="string">"^[^ ]+$"</span>)</span></span>;<span class="comment">// 不能输入空格</span></span><br><span class="line">    QValidator *validator2=<span class="keyword">new</span> QRegExpValidator(regx,<span class="keyword">this</span>);</span><br><span class="line">    passwordEdit-&gt;setValidator(validator2);</span><br><span class="line">    filepasswordEdit-&gt;setValidator(validator2);<span class="comment">//正则表达式控制输入框字符格式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> ConvertDialog::on_shellButton_clicked()<span class="comment">//确定加密按钮触发</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//system("/bin/ecryptfs_mounted.sh /home/tang/");  //直接调用的方式，会阻塞进程</span></span><br><span class="line">    <span class="comment">//QProcess::execute("/opt/run")　　//调用QT里面的函数来实现，会阻塞进程</span></span><br><span class="line"></span><br><span class="line">    passwordEdit-&gt;setInputMask(<span class="string">""</span>);<span class="comment">//提取password输入框内容</span></span><br><span class="line">    filepasswordEdit-&gt;setInputMask(<span class="string">""</span>);<span class="comment">//提取filepassword输入框内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sourceFileEdit-&gt;text().isEmpty()) <span class="comment">//  必须输入加密路径，否则报错</span></span><br><span class="line">    &#123;</span><br><span class="line">         QMessageBox::warning(<span class="keyword">this</span>,tr(<span class="string">"worning"</span>),tr(<span class="string">" Please select the path to encrypt !"</span>),QMessageBox::Yes);<span class="comment">//报错信息</span></span><br><span class="line">          sourceFileEdit-&gt;setFocus();<span class="comment">//移动光标到加密路径输入框</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(passwordEdit-&gt;text().isEmpty()||filepasswordEdit-&gt;text().isEmpty())<span class="comment">//如果任一密码为空，直接报错</span></span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::warning(<span class="keyword">this</span>,tr(<span class="string">"worning"</span>),tr(<span class="string">" user password or file password can't be empty!"</span>),QMessageBox::Yes);</span><br><span class="line">        <span class="comment">//报错信息</span></span><br><span class="line">       passwordEdit-&gt;clear();<span class="comment">//清空用户密码输入框</span></span><br><span class="line">       filepasswordEdit-&gt;clear();<span class="comment">//清空文件密码输入框</span></span><br><span class="line">       passwordEdit-&gt;setFocus();<span class="comment">//移动光标到用户密码输入框</span></span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">    QString p1=passwordEdit-&gt;text().trimmed();<span class="comment">//去除首尾空格</span></span><br><span class="line">    QString f1=filepasswordEdit-&gt;text().trimmed();<span class="comment">// 去除首尾空格</span></span><br><span class="line"></span><br><span class="line">    QString p2,f2;</span><br><span class="line">    <span class="keyword">int</span> length1=p1.length();</span><br><span class="line">    <span class="keyword">int</span> length2=f1.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length1;i++)</span><br><span class="line">    &#123;<span class="keyword">if</span> (p1[i]!=<span class="string">' '</span>) p2+=p1[i];&#125;<span class="comment">//去除password中的空格</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length2;i++)</span><br><span class="line">    &#123;<span class="keyword">if</span> (f1[i]!=<span class="string">' '</span>) f2+=f1[i];&#125;<span class="comment">//去除filepassword中的空格</span></span><br><span class="line"></span><br><span class="line">    QString define = p2+<span class="string">" "</span>+<span class="string">"1 "</span>+f2+<span class="string">" "</span>+ecryptfstypeComboBox-&gt;currentText().toLower()</span><br><span class="line">                    +<span class="string">" "</span>+ecryptfsbitComboBox-&gt;currentText().toLower()</span><br><span class="line">                    +<span class="string">" "</span>+fileecryptfsComboBox-&gt;currentText().toLower()</span><br><span class="line">                    +<span class="string">" "</span>+filenameecryptfsComboBox-&gt;currentText().toLower();<span class="comment">//输出需要的信息</span></span><br><span class="line">    qDebug()&lt;&lt;define;</span><br><span class="line">    QString ecryptfs_sh = sourceFileEdit-&gt;text()+<span class="string">" "</span>+define;<span class="comment">//写出保存的信息</span></span><br><span class="line">    <span class="comment">//ecryptfs_sh.insert(0,QString("/bin/tangguoze "));</span></span><br><span class="line">    qDebug()&lt;&lt;ecryptfs_sh;</span><br><span class="line">    QStringList arguments;</span><br><span class="line">    arguments &lt;&lt; ecryptfs_sh;<span class="comment">//输出信息到脚本中</span></span><br><span class="line">    QProcess *poc = <span class="keyword">new</span> QProcess;<span class="comment">//定义新进程</span></span><br><span class="line">    poc -&gt; start (<span class="string">"/bin/tangguoze"</span>,arguments);<span class="comment">//在QT中调用启动进程运行</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三．eCryptfs开源部分的分析"><a href="#三．eCryptfs开源部分的分析" class="headerlink" title="三．eCryptfs开源部分的分析"></a>三．eCryptfs开源部分的分析</h2><p>主要分为7个部分：</p><ol><li><p>keystore<br>Keystore部件从文件中提供文件头信息，并将信息数据转发给callout应用程序。Keystore与callout应用程序之前使用netlink机制通信，通信的发起者为keystore。</p></li><li><p>Callout应用程序<br>Callout应用程序根据目标策略对头文件信息作出评估，并给出各种操作，如：调用后台给应用程序弹出对话框要求密码短语，或用私钥解密一个会话秘钥。<br>eCryptfs内核模块和用户空间秘钥管理代码之间的主要通信是请求秘钥，由内核秘钥环发起。Callout应用程序从目录分析策略信息，解析每个文件的头信息。为了满足挂起的公钥请求，他可以调用PKI API，或者用特殊的签名搜索带盐值得密码短语。  </p></li><li><p>eCryptfs后台弹出对话框输入密码短语<br>为了能给用户弹出对话框来输入密码短语，eCryptfs必须提供得到X会话的通道。这可能通过运行一个后台来实现。eCryptfs后台侦听一个socket，它的地址信息写在用户的会话秘钥环中，无论何时策略需要弹出一个对话框请求密码短语时，callout应用程序都能提取socket的地址信息，并用它请求后台给用户弹出对话框，接着，后台将用户的密码短语返回给callout应用程序。  </p></li><li><p>内核秘钥环<br>内核秘钥环用于管理和保护秘钥和认证特征。eCryptfs用内核秘钥环存储认证特征、节点加密统计信息和秘钥。  </p></li><li><p>PAM<br>PAM（可插入的认证模块）提供了灵活的认证机制。eCryptfs含有一个模块，能捕获用户注册的密码短语，并将它放在用户的会话秘钥环中，这个密码短语作为无盐值密码短语认证特征。<br>eCryptfs可以基于策略，使用这个密码短语进行加密操作。如：用这个密码短语从用户的GunPG秘钥环中提取他的私钥；通过字符串到秘钥操作，将这个密码短语直接用于保护文件的会话秘钥；这个秘钥短语还可以与存在TPM中的秘钥结合在一起，用来提供两个因子的认证，即用户为了访问一个文件，他必须注册到特殊主机，还需要使用特征的密码短语。  </p></li><li><p>公钥设施<br>eCryptfs提供了可插入的PKI（公钥设施）接口，eCryptfs的PKI模块利用GPGME（GuuPG Made Easy）接口访问用户的GnuPG秘钥环。这个模块能使用用户的注册密码解密用户保存的私钥。<br>eCryptfs的TMP PKI模块的TrouSerS使用接口与TPM（可信平台模块）通信，用来使用存在硬件中的私钥，将文件绑定到一个特定的主机上。<br>eCryptfs openCryptoki PKCS#11框架PKI通过各种open Crytok的硬件设备，对在硬件上执行公钥操作的机制提供了支持。  </p></li><li>目标中心策略（Target-centric Polocies）<br>当应用程序创建一个新文件时，eCryptfs必须作出许多的决策，如：文件是否加密？用哪个对称密码加密数据？文件是否加入HMAC并附加IV？会话秘钥长度是多少？如何保护会话秘钥？等等。<br>eCryptfs将策略定义文件应用于目标。<br>eCryptfs文件系统由内核空间系统和用户空间系统两部分组成。内核空间系统由内核空间的内核keystore、内核加密API、eCryptfs层、加密元数据和底层文件系统组成。而用户空间由callout应用程序，eCryptfs后台和PKI API等组成。<br>另外，eCryptfs文件系统使用了Linux内核的密钥环服务、Linux可插入认证模块(Pluggable Authentication Modules, PAM)、可信平台模块（Trusten Platform Module, TPM）和GnuPG密钥环，Ecryptfs超级块私有数据主要包括加密的各种信息，如：认证特征、密钥环等。  </li></ol><pre>/* superblock private data. */struct ecryptfs_sb_info {    struct super_block *wsi_sb;    struct ecryptfs_mount_crypt_stat mount_crypt_stat;};/* dentry private data. Each dentry must keep track of a lower * vfsmount too. */struct ecryptfs_dentry_info {    struct path lower_path;    struct ecryptfs_crypt_stat *crypt_stat;};/* inode private data. */struct ecryptfs_inode_info {    struct inode vfs_inode;    struct inode *wii_inode;    struct file *lower_file;    struct mutex lower_file_mutex;    struct ecryptfs_crypt_stat crypt_stat;};/* file private data. */struct ecryptfs_file_info {    struct file *wfi_file;    struct ecryptfs_crypt_stat *crypt_stat;};eCryptfs的认证特征包括会话密钥、口令和私钥等以及他们的签名。会话密钥将口令进行加密。结构eCryptfs_auth_toke存放了eCryptfs文件系统范围内的的认证特征。/* May be a password or a private key */struct ecryptfs_auth_tok {    u16 version; /* 8-bit major and 8-bit minor */    u16 token_type;#define ECRYPTFS_ENCRYPT_ONLY 0x00000001    u32 flags;    struct ecryptfs_session_key session_key;    u8 reserved[32];    union {        struct ecryptfs_password password;        struct ecryptfs_private_key private_key;    } token;} __attribute__ ((packed));加密统计信息结构ecryptfs_crypt_stat存入了与每个加密文件相关的加密信息。如：文件的加密操作标识、文件头的结构信息等。列出如下：/** * This is the primary struct associated with each encrypted file. * * TODO: cache align/pack? */struct ecryptfs_crypt_stat {#define ECRYPTFS_STRUCT_INITIALIZED 0x00000001#define ECRYPTFS_POLICY_APPLIED     0x00000002#define ECRYPTFS_NEW_FILE           0x00000004#define ECRYPTFS_ENCRYPTED          0x00000008#define ECRYPTFS_SECURITY_WARNING   0x00000010#define ECRYPTFS_ENABLE_HMAC        0x00000020#define ECRYPTFS_ENCRYPT_IV_PAGES   0x00000040#define ECRYPTFS_KEY_VALID          0x00000080#define ECRYPTFS_METADATA_IN_XATTR  0x00000100#define ECRYPTFS_VIEW_AS_ENCRYPTED  0x00000200#define ECRYPTFS_KEY_SET            0x00000400    u32 flags;    unsigned int file_version;    size_t iv_bytes;    size_t num_header_bytes_at_front;    size_t extent_size; /* Data extent size; default is 4096 */    size_t key_size;    size_t extent_shift;    unsigned int extent_mask;    struct ecryptfs_mount_crypt_stat *mount_crypt_stat;    struct crypto_blkcipher *tfm;    struct crypto_hash *hash_tfm; /* Crypto context for generating                       * the initialization vectors */    unsigned char cipher[ECRYPTFS_MAX_CIPHER_NAME_SIZE];    unsigned char key[ECRYPTFS_MAX_KEY_BYTES];    unsigned char root_iv[ECRYPTFS_MAX_IV_BYTES];    struct list_head keysig_list;    struct mutex keysig_list_mutex;    struct mutex cs_tfm_mutex;    struct mutex cs_hash_tfm_mutex;    struct mutex cs_mutex;};</pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Linux透明加密文件系统代码分析&quot;&gt;&lt;a href=&quot;#Linux透明加密文件系统代码分析&quot; class=&quot;headerlink&quot; title=&quot;Linux透明加密文件系统代码分析&quot;&gt;&lt;/a&gt;Linux透明加密文件系统代码分析&lt;/h1&gt;&lt;p&gt;主要分为三个部分：&lt;
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux系统" scheme="http://yoursite.com/tags/Linux%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Test</title>
    <link href="http://yoursite.com//blog/2018/05/09/Test.html"/>
    <id>http://yoursite.com//blog/2018/05/09/Test.html</id>
    <published>2018-05-09T18:12:25.000Z</published>
    <updated>2018-05-10T04:59:49.367Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com//blog/2018/05/09/hello-world.html"/>
    <id>http://yoursite.com//blog/2018/05/09/hello-world.html</id>
    <published>2018-05-09T18:03:06.965Z</published>
    <updated>2018-05-09T18:03:06.965Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com//blog/2018/05/09/%E5%9F%BA%E4%BA%8ELinux%E9%80%8F%E6%98%8E%E5%8A%A0%E5%AF%86%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0_%E6%A6%82%E8%BF%B0.html"/>
    <id>http://yoursite.com//blog/2018/05/09/基于Linux透明加密文件系统的设计与实现_概述.html</id>
    <published>2018-05-09T04:00:00.000Z</published>
    <updated>2018-05-09T19:23:10.442Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基于Linux透明加密文件系统的设计与实现"><a href="#基于Linux透明加密文件系统的设计与实现" class="headerlink" title="基于Linux透明加密文件系统的设计与实现"></a>基于Linux透明加密文件系统的设计与实现</h1><h1 id="选题背景"><a href="#选题背景" class="headerlink" title="选题背景"></a>选题背景</h1><p>现在人们对计算机系统安全问题考虑的越来越多，对计算机系统安全的要求也越来越严格，数据安全早已不在是军方和政府要害部门的特殊需求。现在，几乎所有的应用领域包括银行、电子交易、政府、互联网络、专用网络和企业内部网络都有数据安全的需求。与此同时个人计算机的数据泄密问题也日益突出。加密技术在现代计算机系统安全中扮演着越来越重要的角色。而加密文件系统是加密技术中比较成熟和通用的方式。</p><h1 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h1><p>对几种现有典型加密文件系统分析，我们可以发现传统的加密文件系统都存在着不同程度的问题，主要集中在这几个方面：数据的保护不完全；性能低下；密钥管理机制不够完善；界面交互性差；透明度差。</p><ul><li>针对用户：普通Ubuntu等Linux系统个人用户者</li><li>用户特点：对命令行操作并不是很熟悉</li></ul><h1 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h1><p>集合需求分析，我们的设计目标是：</p><ul><li>对系统的运算速度不能产生太大的影响；</li><li>整个加解密过程对用户而言是透明的，授权访问者可以很直观的读取文件明文，而非授权访问者读取到的都是已经加密过后的密文；</li><li>在相似的操作系统中能够很好的进行移植。  </li></ul><p>根据这些需求，并结合现有加密文件系统的分析，我们选用堆叠式文件系统的方式来实现。设计的系统框架如下:<br><img src="/img/in-post/18_05_Linux文件加密系统框架示意图.png" alt="18_05_Linux文件加密系统框架示意图"> </p><h1 id="系统简介"><a href="#系统简介" class="headerlink" title="系统简介"></a>系统简介</h1><p>系统的主体功能是通过堆叠式文件系统来实现本地数据的加解密工作，具体需要实现的有：</p><ul><li>加密文件系统开发，以一个独立的内核模块进行部署；</li><li>用户操作界面的开发，对用户更友好；</li><li>用户认证机制和文件加密密码验证结合，提高安全性；</li><li>除了正文，也可以对文件名加密；</li><li>用户可以自由选择下层文件系统来存放加密文件。  </li></ul><h2 id="系统框架"><a href="#系统框架" class="headerlink" title="系统框架"></a>系统框架</h2><h3 id="Read操作"><a href="#Read操作" class="headerlink" title="Read操作"></a>Read操作</h3><p>当用户发起read操作，加密文件系统中相关函数就被VFS中的系统调用sys_read()调用来处理这一个请求，他必须首先调用下层文件系统的read()以读取加密过的文件数据，然后解密文件数据，最后将解密后的原数据返回给用户。<br><img src="/img/in-post/18_05_Linux透明加密文件系统Read操作.png" alt="18_05_Linux透明加密文件系统Read操作"> </p><p>write操作<br>用户进程的write()函数经过系统通用的VFS层，就转化成了系统调用sys_write()；VFS层的系统调用sys_write()函数再调用堆叠式加密文件系统中的encrypt_write()函数，然后compressfs_write()函数对上层用户空间传来的数据进行加密；之后再调用位于加密文件系统下层的具体文件系统中write()函数；将加密后的数据写入底层的具体文件系统当中去。<br><img src="/img/in-post/18_05_Linux透明加密文件系统Write操作.png" alt="18_05_Linux透明加密文件系统Write操作"> </p><h3 id="文件系统详细结构图"><a href="#文件系统详细结构图" class="headerlink" title="文件系统详细结构图"></a>文件系统详细结构图</h3><p><img src="/img/in-post/18_05_09_Linux透明加密文件系统详细结构示意图.png" alt="18_05_09_Linux透明加密文件系统详细结构示意图"> </p><h3 id="秘钥管理"><a href="#秘钥管理" class="headerlink" title="秘钥管理"></a>秘钥管理</h3><p><img src="/img/in-post/18_05_09_Linux透明加密文件系统秘钥管理示意图.png" alt="18_05_09_Linux透明加密文件系统秘钥管理示意图"> </p><h1 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h1><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/img/in-post/18_05_09_Linux透明加密文件系统工作流程示意图.png" alt="18_05_09_Linux透明加密文件系统工作流程示意图"> </p><h2 id="用户操作界面"><a href="#用户操作界面" class="headerlink" title="用户操作界面"></a>用户操作界面</h2><h3 id="用户加解密操作"><a href="#用户加解密操作" class="headerlink" title="用户加解密操作"></a>用户加解密操作</h3><p><img src="/img/in-post/18_05_09_Linux用户操作之加解密图形界面.png" alt="18_05_09_Linux用户操作之加解密图形界面"> </p><h3 id="文件挂载后的操作界面"><a href="#文件挂载后的操作界面" class="headerlink" title="文件挂载后的操作界面"></a>文件挂载后的操作界面</h3><p><img src="/img/in-post/18_05_09_文件系统挂载后操作界面.png" alt="18_05_09_文件系统挂载后操作界面"> </p><h1 id="技术难点"><a href="#技术难点" class="headerlink" title="技术难点"></a>技术难点</h1><h2 id="加密文件系统实现方式选择（三种选择）"><a href="#加密文件系统实现方式选择（三种选择）" class="headerlink" title="加密文件系统实现方式选择（三种选择）"></a>加密文件系统实现方式选择（三种选择）</h2><ul><li>基于应用层来实现文件的加解密；</li><li>修改现有文件系统来实现；</li><li>堆叠式文件系统。  </li></ul><p>综合用户需求我们选择的是第三种方案，用堆叠式文件系统来实现透明加密。</p><h2 id="加密位置的选择"><a href="#加密位置的选择" class="headerlink" title="加密位置的选择"></a>加密位置的选择</h2><p>加密文件系统实现的难点之一在于找到一个Linux核心代码中合适的位置进行加解密操作。加密位置选择得好，便于实现，而且对系统的性能影响要比较小。我们选择的原则就是尽可能的将加解密操作延后。对于写操作，只在实际写入磁盘的时候才进行加密，对于读操作，只有在接近送到用户空间的缓冲区的时候才进行解密，加密的位置要让数据在Buffer Cache中是以明文形式存在的，以便能够利用Linux的缓冲机制提高加密文件系统的性能。反之，假设我们在Linux Buffer Cache层以上进行加解密操作，这就意味着对于加密的文件，Buffer Cache中存在的是密文，每次内核需要Buffer Cache中的内容的时候都要先进行加解密的工作，这将会大大的降低系统的性能。</p><h2 id="交互式脚本书写"><a href="#交互式脚本书写" class="headerlink" title="交互式脚本书写"></a>交互式脚本书写</h2><p>如何书写与文件系统运行时候的交互式脚本，实现加密文件系统的自动化挂载过程。</p><p><img src="/img/in-post/18_05_09_文件系统交互式脚本书写.png" alt="18_05_09_文件系统交互式脚本书写">   </p><h2 id="QT与Shell脚本交互"><a href="#QT与Shell脚本交互" class="headerlink" title="QT与Shell脚本交互"></a>QT与Shell脚本交互</h2><p>如何将QT图形界面获取到的参数传递给脚本，并启动脚本，如何返回脚本的执行情况给图形化界面。</p><p><img src="/img/in-post/18_05_09_QT与Shell脚本交互示意图.png" alt="18_05_09_QT与Shell脚本交互示意图"> </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基于Linux透明加密文件系统的设计与实现&quot;&gt;&lt;a href=&quot;#基于Linux透明加密文件系统的设计与实现&quot; class=&quot;headerlink&quot; title=&quot;基于Linux透明加密文件系统的设计与实现&quot;&gt;&lt;/a&gt;基于Linux透明加密文件系统的设计与实现&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Some Issues With MSI GE60 2PG</title>
    <link href="http://yoursite.com//blog/2018/05/08/Some%20issues%20with%20MSI%20GE60%202PG.html"/>
    <id>http://yoursite.com//blog/2018/05/08/Some issues with MSI GE60 2PG.html</id>
    <published>2018-05-08T16:00:00.000Z</published>
    <updated>2018-05-09T14:03:13.317Z</updated>
    
    <content type="html"><![CDATA[<p>There are some issues when I used my MSI GE60 2PG.  </p><h2 id="1-Sound-Blaster-Cinema-1-Potential-fix-on-Windows-10"><a href="#1-Sound-Blaster-Cinema-1-Potential-fix-on-Windows-10" class="headerlink" title="1. Sound Blaster Cinema 1 Potential fix on Windows 10"></a>1. Sound Blaster Cinema 1 Potential fix on Windows 10</h2><p>A way to get Sound Blaster Cinema 1 fully functional on windows 10 x64 bit. This is a fix for those that attempt to open the program and immediately get a crash or no windows popping up and the system tray icon freezes.</p><blockquote><ol><li>Uninstalled both my realtek HD audio drivers via control panel, and uninstalled SBC. </li><li>Then rebooted and had ccleaner fix any registry errors. Reinstalled the drivers and SBC. </li><li>Go into the programs folder here:<br><code>C:\Program Files (x86)\Creative\Sound Blaster Cinema\Sound Blaster Cinema</code><br>Then delete the SBCinema.exe.config file.</li></ol></blockquote><p>Now the SBC is fully functional on Windows 10 64 bit and hopefully it works for everyone else to!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;There are some issues when I used my MSI GE60 2PG.  &lt;/p&gt;
&lt;h2 id=&quot;1-Sound-Blaster-Cinema-1-Potential-fix-on-Windows-10&quot;&gt;&lt;a href=&quot;#1-Sound-
      
    
    </summary>
    
    
      <category term="laptop" scheme="http://yoursite.com/tags/laptop/"/>
    
      <category term="Win10" scheme="http://yoursite.com/tags/Win10/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com//blog/2017/08/18/ELS-Writing-Class.html"/>
    <id>http://yoursite.com//blog/2017/08/18/ELS-Writing-Class.html</id>
    <published>2017-08-18T04:00:00.000Z</published>
    <updated>2018-05-08T03:01:20.217Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ELS-Writing-class"><a href="#ELS-Writing-class" class="headerlink" title="ELS Writing class"></a>ELS Writing class</h1><h3 id="2-How-to-find-a-Perfect-rental-home-for-students"><a href="#2-How-to-find-a-Perfect-rental-home-for-students" class="headerlink" title="2.How to find a Perfect rental home for students."></a>2.How to find a Perfect rental home for students.</h3><p>&emsp;&emsp;  Renting a home is the most important thing before a student enters university. It requires some progress before going the rent.You need to think about the kind of propery you are looking for. Where you want to live, and the budget you have available. Do you think it’s a painful thing? Believe it or not, renting a good home is not as diffiuclt ad you think, especially if you work through the process following these steps which will make your search smarter and more efficent.  </p><p>&emsp;&emsp;  First, Decide the requirements that you want that you want or need. There are a lot of factors to consider. For instance, write down all the things that you are thinking in mind, the location has to be close the university, the minimum square footage the home, whether you want furnished and unfurnished, the number of bed rooms and bathrooms, garden, and so on. In addition, there are some other requirements which depend on your personal lifestyle. For example, whether the private peoperty owner also resides in the home or whether a couple can share the room.  </p><p>&emsp;&emsp; Next set a budget and stick to it. Search for property to rent online and look at the local prices to make sure that your budget is sensible. In addition to your rental costs, you will also need to budget for other related expenses, such as utility bills, cable and Internet, deposit, removal costs, and some others in order to make your home livable.  </p><p>&emsp;&emsp;  After that, search and select a perfect home. There are a plenty of ways to search a home for you. For example, search online, local newspaper, agents, board in your area, friends and classmates. Then choose a few homes you like.  </p><p>&emsp;&emsp; Finally, call and speak to the landlords of the houses which you have select to make sure the house is in as good condition. Then, compare the houses to select the best one.  </p><p>&emsp;&emsp;   Although you are going to be renting a home rather that buying it. But remember that it will be your home for the immediate future.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ELS-Writing-class&quot;&gt;&lt;a href=&quot;#ELS-Writing-class&quot; class=&quot;headerlink&quot; title=&quot;ELS Writing class&quot;&gt;&lt;/a&gt;ELS Writing class&lt;/h1&gt;&lt;h3 id=&quot;2-How
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com//blog/2017/08/13/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B%EF%BC%95_system_call%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B.html"/>
    <id>http://yoursite.com//blog/2017/08/13/Linux内核分析课程５_system_call中断处理过程.html</id>
    <published>2017-08-13T04:00:00.000Z</published>
    <updated>2018-05-08T03:01:20.217Z</updated>
    
    <content type="html"><![CDATA[<p>　　Linux内核课第四周作业。本文在云课堂中实验楼完成。<br>　　唐国泽 原创作品转载请注明出处 《Linux内核分析》MOOC课程<a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="noopener">http://mooc.study.163.com/course/USTC-1000029000</a></p><hr><p>　　主要内容：<br>　　1.调试sys_exit()<br>　　2.系统调用源代码分析<br>　　3.系统调用小结</p><p>#一.加入自定义的系统调用CallExit.<br>　　修改menu/test.c文件，加入自己定义的系统调用函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include &quot;menu.h&quot;</span><br><span class="line">#include&lt;sys/types.h&gt;</span><br><span class="line">#include&lt;unistd.h&gt;</span><br><span class="line">#define FONTSIZE 10</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">int CallExit(int argc,char *argvs)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pc,pr;</span><br><span class="line">    int t;</span><br><span class="line">    pc =fork();</span><br><span class="line">    if(pc &lt; 0)</span><br><span class="line">        printf(&quot;Fork error!\n&quot;);</span><br><span class="line">    else if(pc == 0)&#123;</span><br><span class="line">        printf(&quot;This is child process with pid of %d\n&quot;,getpid());</span><br><span class="line">        sleep(5);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        pr=wait(NULL);</span><br><span class="line">        printf(&quot;I catched a child process with pid of %d\n&quot;,pr);</span><br><span class="line">    &#125;</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line">int CallExit_asm(int argc,char *argvs)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pc,pr;</span><br><span class="line">    int t;</span><br><span class="line">    pc =fork();</span><br><span class="line">    if(pc &lt; 0)</span><br><span class="line">        printf(&quot;Fork error!\n&quot;);</span><br><span class="line">    else if(pc == 0)&#123;</span><br><span class="line">        printf(&quot;This is child process with pid of %d\n&quot;,getpid());</span><br><span class="line">        sleep(5);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        pr=wait(NULL);</span><br><span class="line">        printf(&quot;I catched a child process with pid of %d\n&quot;,pr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    asm volatile(</span><br><span class="line">            &quot;mov $0x1,%%eax\n\t&quot;</span><br><span class="line">            &quot;mov $0x0,%%ebx\n\t&quot;</span><br><span class="line">            &quot;int $0x80\n\t&quot;</span><br><span class="line">            &quot;mov %%eax,%0\n\t&quot;</span><br><span class="line">            :&quot;=m&quot; (t)</span><br><span class="line">            );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    PrintMenuOS();</span><br><span class="line">    SetPrompt(&quot;MenuOS&gt;&gt;&quot;);</span><br><span class="line">    MenuConfig(&quot;version&quot;,&quot;MenuOS V1.0(Based on Linux 3.18.6)&quot;,NULL);</span><br><span class="line">    MenuConfig(&quot;quit&quot;,&quot;Quit from MenuOS&quot;,Quit);</span><br><span class="line">    MenuConfig(&quot;time&quot;,&quot;Show System Time&quot;,Time);</span><br><span class="line">    MenuConfig(&quot;time-asm&quot;,&quot;Show System Time(asm)&quot;,TimeAsm);</span><br><span class="line">    **MenuConfig(&quot;CallExit&quot;,&quot;Exit Systemcall&quot;,CallExit);**</span><br><span class="line">    **MenuConfig(&quot;CallExit_asm&quot;,&quot;Exit_asm Systemcall&quot;,CallExit_asm);**</span><br><span class="line">    ExecuteMenu();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　即在main函数中，加入相应的系统调用定义，讲CallExit和CallExit_asm加入到其中去，在QEMU中启动系统之后可以输入help看到，我们的命令中多了两条命令。</p><p>　　<img src="http://img.blog.csdn.net/20150405172545647" alt="系统启动时，命令中有了多的系统调用函数">　<br>　可惜在进行系统调用测试的时候出现了问题，导致系统崩溃了，暂时还没有测试出来代码中是什么地方出现了问题，会继续调试找出问题的地方。<br>　　<img src="http://img.blog.csdn.net/20150405181638295" alt="调试的时候出现问题的图片"></p><p>　　关于老师视频中提到的不能调试sys_time的一些分析：<br>　　<a href="http://www.cnblogs.com/hazir/p/syscall_marco_define.html" target="_blank" rel="noopener">Linux Kernel代码艺术——系统调用宏定义</a><br>　　可以参考这一篇文章中的内容，在2.6.28之前的内核代码中，系统调用的时候是直接调用处理函数的，但出现了漏洞CVE-2009-0029漏洞之后，就是通过宏定义的方式来处理系统调用函数了。　　</p><p>#二.系统调用源代码分析<br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"># system call handler stub</span><br><span class="line">ENTRY(system_call)//所有系统调用函数的入口处</span><br><span class="line">RING0_INT_FRAME# can&apos;t unwind into user space anyway</span><br><span class="line">ASM_CLAC</span><br><span class="line">pushl_cfi %eax# 保存系统调用号</span><br><span class="line">SAVE_ALL# 保护现场</span><br><span class="line">GET_THREAD_INFO(%ebp)　#保存当前信息到ebp中</span><br><span class="line"># system call tracing in operation / emulation</span><br><span class="line">testl $_TIF_WORK_SYSCALL_ENTRY,TI_flags(%ebp)</span><br><span class="line">jnz syscall_trace_entry</span><br><span class="line">##判断是否是trace相关的调用</span><br><span class="line">##判断系统调用号是否超出了最大值255</span><br><span class="line">cmpl $(NR_syscalls), %eax</span><br><span class="line">jae syscall_badsys</span><br><span class="line">syscall_call:</span><br><span class="line">call *sys_call_table(,%eax,4)//由系统调用表中的对应系统调用号找服务函数</span><br><span class="line">syscall_after_call:</span><br><span class="line">movl %eax,PT_EAX(%esp)# store the return value</span><br><span class="line">#系统调用返回</span><br><span class="line">syscall_exit:　　　</span><br><span class="line">LOCKDEP_SYS_EXIT</span><br><span class="line">DISABLE_INTERRUPTS(CLBR_ANY)# make sure we don&apos;t miss an interrupt</span><br><span class="line"># setting need_resched or sigpending</span><br><span class="line"># between sampling and the iret</span><br><span class="line">TRACE_IRQS_OFF</span><br><span class="line">movl TI_flags(%ebp), %ecx</span><br><span class="line"></span><br><span class="line">##退出系统调用之前，检查是否需要处理信号</span><br><span class="line">testl $_TIF_ALLWORK_MASK, %ecx# current-&gt;work</span><br><span class="line">jne syscall_exit_work</span><br><span class="line">#恢复处理器工作</span><br><span class="line">restore_all:</span><br><span class="line">TRACE_IRQS_IRET</span><br><span class="line">restore_all_notrace:</span><br><span class="line">#ifdef CONFIG_X86_ESPFIX32</span><br><span class="line">movl PT_EFLAGS(%esp), %eax# mix EFLAGS, SS and CS</span><br><span class="line"># Warning: PT_OLDSS(%esp) contains the wrong/random values if we</span><br><span class="line"># are returning to the kernel.</span><br><span class="line"># See comments in process.c:copy_thread() for details.</span><br><span class="line">movb PT_OLDSS(%esp), %ah</span><br><span class="line">movb PT_CS(%esp), %al</span><br><span class="line">andl $(X86_EFLAGS_VM | (SEGMENT_TI_MASK &lt;&lt; 8) | SEGMENT_RPL_MASK), %eax</span><br><span class="line">cmpl $((SEGMENT_LDT &lt;&lt; 8) | USER_RPL), %eax</span><br><span class="line">CFI_REMEMBER_STATE</span><br><span class="line">je ldt_ss# returning to user-space with LDT SS</span><br><span class="line">#endif</span><br><span class="line">restore_nocheck:</span><br><span class="line">RESTORE_REGS 4# skip orig_eax/error_code</span><br><span class="line">irq_return:</span><br><span class="line">INTERRUPT_RETURN　　//中断系统调用的处理过程，结束点iret</span><br><span class="line">.section .fixup,&quot;ax&quot;</span><br><span class="line">ENTRY(iret_exc)</span><br><span class="line">pushl $0# no error code</span><br><span class="line">pushl $do_iret_error</span><br><span class="line">jmp error_code</span><br><span class="line">.previous</span><br><span class="line">_ASM_EXTABLE(irq_return,iret_exc)</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_X86_ESPFIX32</span><br><span class="line">CFI_RESTORE_STATE</span><br><span class="line">ldt_ss:</span><br><span class="line">#ifdef CONFIG_PARAVIRT</span><br><span class="line">cmpl $0, pv_info+PARAVIRT_enabled</span><br><span class="line">jne restore_nocheck</span><br><span class="line">#endif</span><br><span class="line">#define GDT_ESPFIX_SS PER_CPU_VAR(gdt_page) + (GDT_ENTRY_ESPFIX_SS * 8)</span><br><span class="line">mov %esp, %edx/* load kernel esp */</span><br><span class="line">mov PT_OLDESP(%esp), %eax/* load userspace esp */</span><br><span class="line">mov %dx, %ax/* eax: new kernel esp */</span><br><span class="line">sub %eax, %edx/* offset (low word is 0) */</span><br><span class="line">shr $16, %edx</span><br><span class="line">mov %dl, GDT_ESPFIX_SS + 4 /* bits 16..23 */</span><br><span class="line">mov %dh, GDT_ESPFIX_SS + 7 /* bits 24..31 */</span><br><span class="line">pushl_cfi $__ESPFIX_SS</span><br><span class="line">pushl_cfi %eax/* new kernel esp */</span><br><span class="line">/* Disable interrupts, but do not irqtrace this section: we</span><br><span class="line"> * will soon execute iret and the tracer was already set to</span><br><span class="line"> * the irqstate after the iret */</span><br><span class="line">DISABLE_INTERRUPTS(CLBR_EAX)</span><br><span class="line">lss (%esp), %esp/* switch to espfix segment */</span><br><span class="line">CFI_ADJUST_CFA_OFFSET -8</span><br><span class="line">jmp restore_nocheck</span><br><span class="line">#endif</span><br><span class="line">CFI_ENDPROC</span><br><span class="line">ENDPROC(system_call)</span><br><span class="line"></span><br><span class="line"># perform work that needs to be done immediately before resumption</span><br><span class="line">ALIGN</span><br><span class="line">RING0_PTREGS_FRAME# can&apos;t unwind into user space anyway</span><br><span class="line"></span><br><span class="line">work_pending:</span><br><span class="line">testb $_TIF_NEED_RESCHED, %cl  #检查是否需要重新调度</span><br><span class="line">jz work_notifysig　　#不需要重新调度，调到work_notifysig</span><br><span class="line"></span><br><span class="line">work_resched:　　　#重新调度</span><br><span class="line">call schedule#进程调度</span><br><span class="line">LOCKDEP_SYS_EXIT</span><br><span class="line">DISABLE_INTERRUPTS(CLBR_ANY)# make sure we don&apos;t miss an interrupt</span><br><span class="line"># setting need_resched or sigpending</span><br><span class="line"># between sampling and the iret</span><br><span class="line">TRACE_IRQS_OFF</span><br><span class="line">movl TI_flags(%ebp), %ecx</span><br><span class="line">andl $_TIF_WORK_MASK, %ecx# is there any work to be done other</span><br><span class="line"># than syscall tracing?</span><br><span class="line">jz restore_all　　//没有其余事情，则恢复现场</span><br><span class="line">testb $_TIF_NEED_RESCHED, %cl</span><br><span class="line">jnz work_resched</span><br><span class="line"></span><br><span class="line">work_notifysig:# deal with pending signals and</span><br><span class="line"># notify-resume requests</span><br><span class="line">#ifdef CONFIG_VM86</span><br><span class="line">testl $X86_EFLAGS_VM, PT_EFLAGS(%esp)</span><br><span class="line">movl %esp, %eax</span><br><span class="line">jne work_notifysig_v86# returning to kernel-space or</span><br><span class="line"># vm86-space</span><br><span class="line">1:</span><br><span class="line">#else</span><br><span class="line">movl %esp, %eax</span><br><span class="line">#endif</span><br><span class="line">TRACE_IRQS_ON</span><br><span class="line">ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">movb PT_CS(%esp), %bl</span><br><span class="line">andb $SEGMENT_RPL_MASK, %bl</span><br><span class="line">cmpb $USER_RPL, %bl</span><br><span class="line">jb resume_kernel</span><br><span class="line">xorl %edx, %edx</span><br><span class="line">call do_notify_resume　　#进行信号处理</span><br><span class="line">jmp resume_userspace</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_VM86</span><br><span class="line">ALIGN</span><br><span class="line">work_notifysig_v86:</span><br><span class="line">pushl_cfi %ecx# save ti_flags for do_notify_resume</span><br><span class="line">call save_v86_state# %eax contains pt_regs pointer</span><br><span class="line">popl_cfi %ecx</span><br><span class="line">movl %eax, %esp</span><br><span class="line">jmp 1b</span><br><span class="line">#endif</span><br><span class="line">END(work_pending)</span><br><span class="line"></span><br><span class="line"># perform syscall exit tracing</span><br><span class="line">ALIGN</span><br><span class="line">syscall_trace_entry:</span><br><span class="line">movl $-ENOSYS,PT_EAX(%esp)</span><br><span class="line">movl %esp, %eax</span><br><span class="line">call syscall_trace_enter</span><br><span class="line">/* What it returned is what we&apos;ll actually use.  */</span><br><span class="line">cmpl $(NR_syscalls), %eax</span><br><span class="line">jnae syscall_call</span><br><span class="line">jmp syscall_exit</span><br><span class="line">END(syscall_trace_entry)</span><br><span class="line"></span><br><span class="line"># perform syscall exit tracing</span><br><span class="line">ALIGN</span><br><span class="line">syscall_exit_work:#完成其他工作</span><br><span class="line">testl $_TIF_WORK_SYSCALL_EXIT, %ecx</span><br><span class="line"> #检查是否系统调用跟踪,审计,单步执行,不需要则跳到work_pending(进行调度,信号处理)  </span><br><span class="line">jz work_pending</span><br><span class="line">TRACE_IRQS_ON</span><br><span class="line">ENABLE_INTERRUPTS(CLBR_ANY)# could let syscall_trace_leave() call</span><br><span class="line"># schedule() instead</span><br><span class="line">movl %esp, %eax</span><br><span class="line">call syscall_trace_leave</span><br><span class="line">jmp resume_userspace</span><br><span class="line">END(syscall_exit_work)</span><br><span class="line">CFI_ENDPROC</span><br><span class="line"></span><br><span class="line">RING0_INT_FRAME# can&apos;t unwind into user space anyway</span><br><span class="line">syscall_fault:</span><br><span class="line">ASM_CLAC</span><br><span class="line">GET_THREAD_INFO(%ebp)</span><br><span class="line">movl $-EFAULT,PT_EAX(%esp)</span><br><span class="line">jmp resume_userspace</span><br><span class="line">END(syscall_fault)</span><br><span class="line"></span><br><span class="line">syscall_badsys:</span><br><span class="line">movl $-ENOSYS,%eax</span><br><span class="line">jmp syscall_after_call</span><br><span class="line">END(syscall_badsys)</span><br><span class="line"></span><br><span class="line">sysenter_badsys:</span><br><span class="line">movl $-ENOSYS,%eax</span><br><span class="line">jmp sysenter_after_call</span><br><span class="line">END(sysenter_badsys)</span><br><span class="line">CFI_ENDPROC</span><br><span class="line"></span><br><span class="line">.macro FIXUP_ESPFIX_STACK</span><br><span class="line">/*</span><br><span class="line"> * Switch back for ESPFIX stack to the normal zerobased stack</span><br><span class="line"> *</span><br><span class="line"> * We can&apos;t call C functions using the ESPFIX stack. This code reads</span><br><span class="line"> * the high word of the segment base from the GDT and swiches to the</span><br><span class="line"> * normal stack and adjusts ESP with the matching offset.</span><br><span class="line"> */</span><br><span class="line">#ifdef CONFIG_X86_ESPFIX32</span><br><span class="line">/* fixup the stack */</span><br><span class="line">mov GDT_ESPFIX_SS + 4, %al /* bits 16..23 */</span><br><span class="line">mov GDT_ESPFIX_SS + 7, %ah /* bits 24..31 */</span><br><span class="line">shl $16, %eax</span><br><span class="line">addl %esp, %eax/* the adjusted stack pointer */</span><br><span class="line">pushl_cfi $__KERNEL_DS</span><br><span class="line">pushl_cfi %eax</span><br><span class="line">lss (%esp), %esp/* switch to the normal stack segment */</span><br><span class="line">CFI_ADJUST_CFA_OFFSET -8</span><br><span class="line">#endif</span><br><span class="line">.endm</span><br><span class="line">.macro UNWIND_ESPFIX_STACK</span><br></pre></td></tr></table></figure></p><p>   SAVE_ALL保存现场函数的宏定义如下图所示：<br><img src="http://img.blog.csdn.net/20150405185021135" alt="这里写图片描述"></p><p>#三.系统调用小结<br>　　系统调用流程小结：</p><p>　　1.执行用户程序(如:fork,exit)<br>　　2.根据glibc中的函数实现，取得系统调用号并执行int $0x80产生中断。<br>　　3.进行地址空间的转换和堆栈的切换，执行SAVE_ALL。（进行内核模式）<br>　　4.进行中断处理，根据系统调用表调用内核函数。<br>　　5.执行内核函数。<br>　　6.执行RESTORE_ALL并返回用户模式<br>　　类似中断处理过程，可以知道，在中断当中这个整体的框架是不变化的的，只是相应的系统调用号和处理函数之间的转化变化成了中断号和中断处理函数之间的转化。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: int0x80-&gt;ENTRY(system_call)</span><br><span class="line">e=&gt;end: Ende|future:&gt;http://www.google.com</span><br><span class="line">op1=&gt;operation: SAVE_ALL(保存现场)|past</span><br><span class="line">op2=&gt;operation: call *sys_call_table</span><br><span class="line">op3=&gt;operation: 系统调用处理程序将返回值存入eax</span><br><span class="line">cond1=&gt;condition: 是否有其他信号或调度</span><br><span class="line">io=&gt;inputoutput: 处理其他信号|future</span><br><span class="line">cond2=&gt;condition: 是否有调度信号</span><br><span class="line">op4=&gt;operation: call_schedule（进程调度）</span><br><span class="line">op5=&gt;operation: RESTORE_ALL(恢复现场)</span><br><span class="line">op6=&gt;operation: INTRRRUPT_RET(iret)</span><br><span class="line">　　返回用户进程</span><br><span class="line">op7=&gt;operation: 保存中断，调用上下文，调度</span><br><span class="line">op8=&gt;operation: 未来再调度回来</span><br><span class="line">cond3=&gt;condition: 是否有退出信号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">st-&gt;op1-&gt;op2-&gt;op3-&gt;cond1</span><br><span class="line">cond1(no,lift)-&gt;op5-&gt;op6</span><br><span class="line">cond1(yes,right)-&gt;io-&gt;cond3(no)-&gt;cond2(yes)-&gt;op4-&gt;op7-&gt;op8</span><br><span class="line">op8(right)-&gt;op5</span><br><span class="line">cond2(no,right)-&gt;op5</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Linux内核课第四周作业。本文在云课堂中实验楼完成。&lt;br&gt;　　唐国泽 原创作品转载请注明出处 《Linux内核分析》MOOC课程&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com//blog/2017/06/06/%E3%80%8A%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB--%E9%93%BE%E6%8E%A5%E3%80%81%E8%A3%85%E8%BD%BD%E4%B8%8E%E5%BA%93%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0.html"/>
    <id>http://yoursite.com//blog/2017/06/06/《程序员的自我修养--链接、装载与库》第一章阅读笔记.html</id>
    <published>2017-06-06T04:00:00.000Z</published>
    <updated>2018-05-08T03:01:20.202Z</updated>
    
    <content type="html"><![CDATA[<p>   《程序员的自我修养–链接、装载与库》第一章阅读笔记<br>     Terry.Tang 原创作品转载请注明出处 《程序员的自我修养–链接、装载与库》阅读笔记1/13<br>     2017/4/18</p><hr><p>#一.基本概念<br>回顾计算机软硬件体系中的几个重要概念，在计算机繁多的硬件设备中，三个部件最为关键：重要处理器CPU、内存和I/0控制芯片。而我们程序员的目的就是充分利用这三个部分。</p><ul><li><strong>南北桥结构</strong><br>1.设计原因：分离低速设备和高速设备，简化单一的北桥结构的设计成本。<br>2.设计方式：南桥(ISA)负责处理低速设备—Modern, Sound card, Printer等；北桥(PCI)负责处理高速设备—内存，USB接口，图形设备等；南北桥硬件结构图如下图所示：</li></ul><p><img src="http://img.blog.csdn.net/20170418113117265?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGFuZzE1MjQ1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><ul><li><p><strong>SMP和多核</strong><br>对称多处理器(SMP,Symmetrical Multi-Processing）: 多个CPU并行，所处地位和功能一样，相互对称的。<br><strong>缺点</strong>：我们的程序并不能同时分解成多个不相干的子问题同时运行在各个CPU上；并且成本太高<br><strong>使用场合</strong>：大型数据库，网络服务器上，同时处理相互独立的大量请求<br><strong>改进方式</strong>：保留多个核心，共享价格昂贵的缓存部件—–多核处理器（Multi-core Processor）</p></li><li><p><strong>系统软件</strong><br>可大致分为两类：<br>1.平台软件—操作系统，驱动程序，运行库，系统工具（应用程序）<br>2.辅助程序开发—编译器，汇编器，链接器等开发工具和开发库<br><strong>本书重点介绍：链接器，运行库和开发库</strong></p><p>计算机系统软件体系结构中–分层结构的几个概念：<br><strong>接口(Interface)：</strong>每个层次之间相互通信的通信协议，接口的下面层来提供并定义接口，接口的上面层来使用接口提供的功能—-接口尽可能保持不变，向后兼容<br><strong>中间层</strong>：除了硬件和应用程序，其他都是中间层</p></li></ul><p><img src="http://img.blog.csdn.net/20170418115137592?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGFuZzE1MjQ1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>比如：系统调用接口的实现是通过软件中断(Software Interrupt)的方式提供的，Linux—0x80中断号； Window—0x2E号中断</p><p>#二.操作系统<br><strong>两个功能：</strong>提供抽象的接口和管理硬件资源</p><ul><li><p><strong>1.CPU利用率</strong><br>演变方式：单一运行一个程序–&gt;多道运行程序–&gt;分手系统—&gt;多任务系统(使得多进程能很好共享CPU)<br>操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别。所有的应用程序都以进程（Process）的方式运行在比操作系统权限更低的级别，每个进程都有独立的地址空间，使得进程之间的地址空间相互隔离。<br><strong>多任务系统中：目前CPU分配方式比较流行的是抢占式(Preemptive)—优先级决定</strong></p></li><li><p><strong>2.I/O设备驱动</strong><br>操作系统作为硬件层的上层，是对硬件的管理和抽象，其中的硬件设备驱动程序处理所有的硬件细节，它和操作系统内核一起运行在特权级，但和内核只有有一定的独立性。<br>设备驱动程序的开发工作一般由硬件厂家完成，操作系统为其提供相应的接口和框架，凡是按照这个接口和框架进行开发的驱动程序都能够。<br>#三.内存利用</p></li></ul><p>当多任务系统出现之后，CPU的利用率得到提升，那么接下来有一个明显的问题：<strong>如何将计算机上有限的物理内存分配给多个程序使用</strong><br>原始的物理内存直接使用的方式存在以下几个问题：<br>1.地址空间不隔离：恶意的程序可以修改其他程序的内存数据，导致其他任务崩溃<br>2.内存使用效率低：程序执行时，监控程序需要将整个程序装入内存中开始运行，任务切换时候，内存不够，则将当前运行程序写回到磁盘中。—大量数据换入换出，效率十分低下<br>3.程序运行的地址不确定：内存给程序的空闲区域的位置是不确定的，不利于编写程序，因为程序编写时，访问数据和指令跳转时的目的地址很多都是固定的。<br>——为了解决这几个问题，增加中间层—虚拟地址，通过某些映射的方式，将整个虚拟地址转换成实际的物理地址。</p><ul><li><p><strong>1.解决隔离问题</strong><br>程序的最佳执行环境：一个单一的地址空间，自己的CPU，占有整个计算机资源不用关心其他的程序。<br>地址空间概念：可想象成一个很大的数组，每个数组的元素是一个字节，而这个数组大小由地址空间的地址长度决定，比如32位（地址线决定是多少位）的地址空间位4GB。<br><strong>地址空间可分为虚拟地址空间（Virtual Address Space） &amp; 物理地址空间（Physical Address Space）</strong><br>注意：物理地址空间可能是4G，但是可能由于内存条只有2G，所有有效的物理地址就只是前面2G了<br><strong>解决地址空间不隔离和运行地址不确定的方式——-分段(Segmentation)</strong></p><p>  <strong>分段(Segmentation)</strong><br>  由操作系统设置映射函数,实际由硬件完成，将程序所需要的内存大小的虚拟空间映射到某个地址空间。<br>  <img src="http://img.blog.csdn.net/20170418200253207?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGFuZzE1MjQ1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>  <strong>解决内存使用效率低下的问题——-分页(Paging)</strong><br>  <strong>分页(Paging)</strong><br>  概念：把地址空间(虚拟&amp;物理)人为地等分成固定大小的页，每一页的大小由硬件决定，或者硬件支持多种大小的页，由操作系统来选择决定页的大小。<br>  当我们把进程的虚拟地址空间按页分割，把常用的数据和代码页装载到内存中，把不常用的代码和数据保存到磁盘中，在需要用的时候再把它从磁盘中取出来即可(页错误中断)。<br>  <img src="http://img.blog.csdn.net/20170418201138609?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdGFuZzE1MjQ1Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>注意：虚拟存储的使用依靠MMU的部件(集成在CPU内部)来完成页映射。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;   《程序员的自我修养–链接、装载与库》第一章阅读笔记&lt;br&gt;     Terry.Tang 原创作品转载请注明出处 《程序员的自我修养–链接、装载与库》阅读笔记1/13&lt;br&gt;     2017/4/18&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;#一.基本概念&lt;br&gt;回顾计算机软硬件体
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com//blog/2017/06/06/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B_%E5%AD%A6%E4%B9%A0%E7%B4%A2%E5%BC%95%EF%BC%88%E6%80%BB%E7%BB%93%EF%BC%89.html"/>
    <id>http://yoursite.com//blog/2017/06/06/Linux内核分析课程_学习索引（总结）.html</id>
    <published>2017-06-06T04:00:00.000Z</published>
    <updated>2018-05-08T03:01:20.202Z</updated>
    
    <content type="html"><![CDATA[<p>　　唐国泽 原创作品转载请注明出处 《Linux内核分析》MOOC课程<a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="noopener">http://mooc.study.163.com/course/USTC-1000029000</a></p><hr><p>#一.学习目录索引<br> 　　Linux内核分析学习博客整理：<br> 　　<a href="http://blog.csdn.net/tang152453/article/details/44087589" target="_blank" rel="noopener">Linux内核分析课程1_计算机是如何工作的</a><br> 　　计算机的工作过程，一言以蔽之：执行程序的过程；所以分析计算机的工作原理也就是分析计算机存储程序，执行程序的原理，所以，我们就需要先通过了解程序存储的这个过程。<br> 　　这篇博客主要分析了计算机的组成和计算机的工作原理，并例举C语言和汇编的转化，最后给出了程序执行时候堆栈变化的动态示意图。<br> 　　<br>　　<a href="http://blog.csdn.net/tang152453/article/details/44204925" target="_blank" rel="noopener">Linux内核分析课程2_操作系统是如何工作的</a><br>　　操作系统的工作原理，可以说是计算机工作原理的第二部分：程序控制的过程，程序控制的体现有中断，系统调用，进程调度等。<br>　　博客中主要分析了操作系统的工作过程，用了一个时间中断函数来模拟了中断程序执行的过程，并给出了相应的堆栈变化示意图。</p><p> 　　<a href="http://blog.csdn.net/tang152453/article/details/44536913" target="_blank" rel="noopener">Linux内核分析课程3_start_kernel()函数分析</a><br> 　　start_kernel()这个函数是内核由引导程序引导以后，由自解压程序解压以后执行的第一个函数，可以认为是整个内核的入口函数，start_kernel()做的工作就是线性的初始化一些内核的基础机制，如中断，内存管理，进程管理，信号，文件系统，KO等！最后就启动一个init线程，init线程再读取文件系统里的init程序，做为系统的第一个进程而存在！<br> 　　博客中对linux启动过程中的start_kernel()函数进行分析，了解其主要的实现功能，在这里，主要对代码进行了解析。<br> 　　主要解析了：start_kernel() -&gt; rest_init() -&gt; kernel_init() -&gt; 启动init进程<br> 　　<br> 　　<a href="http://blog.csdn.net/tang152453/article/details/44726799" target="_blank" rel="noopener">Linux内核分析课程4_Linux系统调用</a><br> 　　系统调用，顾名思义，说的是操作系统提供给用户程序调用的一组“特殊”接口。用户程序可以通过这组“特殊”接口来获得操作系统内核提供的服务，比如用户可以通过文件系统相关的调用请求系统打开文件、关闭文件或读写文件，可以通过时钟相关的系统调用获得系统时间或设置定时器等。<br> 　　从逻辑上来说，系统调用可被看成是一个内核与用户空间程序交互的接口——它好比一个中间人，把用户进程的请求传达给内核，待内核把请求处理完毕后再将处理结果送回给用户空间。<br> 　　博客中详细的分析了系统调用的原理，实现方式和意义；API，系统调用，系统命令，内核函数之间的区别，最后分别用C语言和汇编来实现了exit系统调用。</p><p> 　　<a href="http://blog.csdn.net/tang152453/article/details/44888515" target="_blank" rel="noopener">Linux内核分析课程5_system_call中断处理过程</a><br> 　　　系统调用流程介绍：<br>　　　1.执行用户程序(如:fork,exit)<br>　　　2.根据glibc中的函数实现，取得系统调用号并执行int $0x80产生中断。<br>　　　3.进行地址空间的转换和堆栈的切换，执行SAVE_ALL。（进行内核模式）<br>　　　4.进行中断处理，根据系统调用表调用内核函数。<br>　　　5.执行内核函数。<br>　　　6.执行RESTORE_ALL并返回用户模式<br> 　　本文中使用gdb调试了sys_exit系统调用，并对系统调用的源代码进行了详细的分析。<br> 　　<br>　　<a href="http://blog.csdn.net/tang152453/article/details/45011085" target="_blank" rel="noopener">Linux内核分析课程6_进程创建</a><br>　　在 Linux 内核中,供用户创建进程的系统调用fork()函数的响应函数是 sys_fork()、sys_clone()、sys_vfork()。这三个函数都是通过调用内核函数 do_fork() 来实现的。<br>　　本篇博客详细分析了进程创建过程(fork())的详细执行过程。<br>　　<br>　　<a href="http://blog.csdn.net/tang152453/article/details/45126661" target="_blank" rel="noopener">Linux内核分析课程7_execve()函数对应的系统调用处理过程</a><br>　　昔者庄周梦为蝴蝶，栩栩然蝴蝶也，自喻适志与，不知周也。俄然觉，则蘧蘧然周也。不知周之梦为蝴蝶与，蝴蝶之梦为周与？周与蝴蝶，则必有分矣。此之谓物化。（《庄子·齐物论》）<br>　　在我们的操作系统中,也有如此浪漫情怀的庄生梦蝶—–exec()函数族.<br>　　博客中中对exec()函数族进行了介绍，之后对do_execve()函数进行了分析。<br>　　<br> 　　<a href="http://blog.csdn.net/tang152453/article/details/45287701" target="_blank" rel="noopener">Linux内核分析课程8_进程调度与进程切换过程</a><br> 　　进程调度中schedule()函数选择一个新的进程来运行，并调用context_switch进行上下文的切换，这个宏调用switch_to来进行关键上下文切换。主要调用过程：<br>　　　　next = pick_next_task(rq, prev);//进程调度算法都封装这个函数内部<br>　　　　context_switch(rq, prev, next);//进程上下文切换<br>　　　　switch_to利用了prev和next两个参数：prev指向当前进程，next指向被调度的进程<br> 　　博客中对schedule函数进行了相关介绍，以及分析了schedule函数的内核实现的详细流程。</p><hr><p>#二.学习心得<br>  1.对Linux系统的认识<br>  　　很幸运参加了这为期两个月的MOOC课程《Linux内核分析》，让我对Linux系统有了更深的认识。<br>  　　Linux系统的开源思想是最值得我们学习的，开源的思想也会成为我们软件行业的主导的。<br>  　　Linux系统最为核心也就是进程调度，中断处理，时钟和文件系统，我们只要对这几个方面了解到了，也就了解了Linux系统的关键了。</p><p>2.学习Linux内核的心得<br>　　学习Linux内核的过程也半年多了，从嵌入式系统设计中的ucos初步认识操作系统(核心：进程调度)，嵌入式操作系统中的（ARM中的Linux）再到Linux内核分析(x86体系下)，一步一步的深入，在这个过程中，有几本书对我影响很多，给大家推荐一下，第一本《Linux内核设计与实现》，想学习linux内核就要先了解相应的机制之后再去看源代码的话，可能会收获到更多，而这本书介绍了诸如进程管理、系统调用、中断和中断处理程序、内核同步、时间管理、内存管理、地址空间、调试技术等方面，内容比较浅显易懂，比较适合学习Linux内核的新人学习；之后就不得不提到《深入理解Linux内核》这本书了，这本最好是能深入学习。简而言之，第一本，提纲性阅读；第二本，适合深入阅读。<br>　　当然，纸上得来终觉浅，绝知此事要躬行；在书本学习的基础上，需要我们利用好gdb这个调试工具，多跟踪一下内核的一些机制的执行流程，在实践中验证知识，才能更好的掌握知识。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　唐国泽 原创作品转载请注明出处 《Linux内核分析》MOOC课程&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mooc.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com//blog/2017/06/06/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B8_%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B.html"/>
    <id>http://yoursite.com//blog/2017/06/06/Linux内核分析课程8_进程调度与进程切换过程.html</id>
    <published>2017-06-06T04:00:00.000Z</published>
    <updated>2018-05-08T03:01:20.202Z</updated>
    
    <content type="html"><![CDATA[<p>　　Linux内核课第八周作业。本文在云课堂中实验楼完成。<br>　　唐国泽 原创作品转载请注明出处 《Linux内核分析》MOOC课程<a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="noopener">http://mooc.study.163.com/course/USTC-1000029000</a> </p><hr><p>#一.schedule()函数介绍</p><p>##１.进程调度的时机<br>　　中断处理过程（包括<strong>时钟中断、I/O中断、系统调用和异常</strong>）中，直接调用schedule()，或者返回用户态时根据need_resched标记调用schedule()；<br>　　<strong>内核线程</strong>可以<strong>直接</strong>调用<strong>schedule()</strong>进行进程切换，也可以在中断处理过程中进行调度，也就是说内核线程作为一类的特殊的进程可以主动调度，也可以被动调度；<br>　　<strong>用户态进程无法实现主动调度，仅能通过陷入内核态后的某个时机点进行调度</strong>，即在中断处理过程中进行调度。</p><p>##2.进程的切换<br>　　为了控制进程的执行，内核必须有能力挂起正在CPU上执行的进程，并恢复以前挂起的某个进程的执行，这叫做进程切换、任务切换、上下文切换；<br>　　挂起正在CPU上执行的进程，与中断时保存现场是不同的，中断前后是在同一个进程上下文中，只是由用户态转向内核态执行；<br>　　进程上下文包含了进程执行需要的所有信息：<br>　　1)用户地址空间：包括程序代码，数据，用户堆栈等<br>　　2)控制信息：进程描述符，内核堆栈等<br>　　3)硬件上下文（注意中断也要保存硬件上下文只是保存的方法不同）</p><p>##3.具体进程切换的代码分析<br>　　<strong>schedule()函数</strong>选择一个新的进程来运行，并调用<strong>context_switch</strong>进行上下文的切换，这个<strong>宏调用switch_to</strong>来进行关键上下文切换：<br>　　主要调用过程：<br>　　　　next = pick_next_task(rq, prev);//进程调度算法都封装这个函数内部<br>　　　　context_switch(rq, prev, next);//进程上下文切换<br>　　　　switch_to利用了prev和next两个参数：prev指向当前进程，next指向被调度的进程</p><p>###1)schedule()函数<br>　　首先，切换时候，调用call schedule()；来执行schedule（）函数，如下图所示：<br>　　<img src="http://img.blog.csdn.net/20150426132041286" alt="这里写图片描述"><br>　　使用struct task_struct *tsk = current; 来获取当前进程；sched_submit_work(tsk);  避免死锁；最后调用＿schedule()来处理切换过程</p><p>###２)＿schedule()函数<br>　　<img src="http://img.blog.csdn.net/20150426132355288" alt="这里写图片描述"><br>　　其中 need_resched:为切换前的变量准备：<br>　　　　preempt_disable()；//禁止内核抢占；<br>　　　　cpu = smp_processor_id(); //获取当前CPU<br>　　　　rq = cpu_rq(cpu);    //获取该CPU维护的运行队列（run queue)<br>　　　　rcu_note_context_switch(cpu);  //更新全局状态，标识当前CPU发生上下文的切换<br>　　　　prev = rq-&gt;curr;    //运行队列中的curr指针赋予prev。</p><p>　　<img src="http://img.blog.csdn.net/20150426132741339" alt="这里写图片描述"><br>　　其中的next=pick_next_task(rq, prev)来确定使用哪一种进程调度的策略，但总是选择了下一个进程来进行切换，即根据调度策略选择一个优先级最高的任务将其定为下一个进程，最后都是调用context_switch来进行进程上下文的切换过程．</p><p>###３)context_switch函数解析<br>　　<img src="http://img.blog.csdn.net/20150426132853739" alt="这里写图片描述"><br>　　其中prepare_task_switch（）函数是完成切换前的准备工作；接着后面判断当前进程是不是内核线程，如果是内核线程，则不需要切换上下文<br>　　<img src="http://img.blog.csdn.net/20150426144441350" alt="这里写图片描述">　<br>　　接着调用switch_mm(),把虚拟内存从一个进程映射切换到新进程中<br>　　调用switch_to(),从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息<br>　　(１)如果next是内核线程，则线程使用prev所使用的地址空;schedule( )函数把该线程设置为懒惰TLB模式<br>　　事实上，每个内核线程并不拥有自己的页表集(task_struct-&gt;mm = NULL)；更确切地说，它使用一个普通进程的页表集。不过，没有必要使一个用户态线性地址对应的TLB表项无效，因为内核线程不访问用户态地址空间。<br><img src="http://img.blog.csdn.net/20150426145627173" alt="这里写图片描述"></p><p>　　(２)如果next是一个普通进程，schedule( )函数用next的地址空间替换prev的地址空间<br>　　|————————————–|<br>　　|   } else                             |<br>　　|       switch_mm(oldmm, mm, next);    |<br>　　|————————————–|</p><p>　　(３)如果prev是内核线程或正在退出的进程，context_switch()函数就把指向prev内存描述符的指针保存到运行队列的prev_mm字段中，然后重新设置prev-&gt;active_mm<br>　　<img src="http://img.blog.csdn.net/20150426145745626" alt="这里写图片描述"><br>　　context_switch()最后调用switch_to()执行prev和next之间的进程切换了<br>　　　　|———————————-|<br>　　　　|   switch_to(prev, next, prev);   |<br>　　　　|———————————-|<br>   　　　　 return prev;<br>　　　　}</p><p>###４)switch_to（）函数解析　<br>　　<img src="http://img.blog.csdn.net/20150426133034297" alt="这里写图片描述"><br>　　switch_to(prev, next, prev)：切换堆栈和寄存器的状态．<br>　　<img src="http://img.blog.csdn.net/20150426133255814" alt="这里写图片描述"><br>　　switch_to是一个宏定义，完成的工作主要是：<br>　　(1)保存当前进程的flags状态和当前进程的ebp<br>　　“pushfl\n\t”        /<em> save    flags </em>/<br>　　“pushl %%ebp\n\t”        /<em> save    EBP  </em>/<br>　　(2)完成内核堆在esp的切换<br>　　 “movl %%esp,%[prev_sp]\n\t”    /<em> save    ESP   </em>/<br>　　 “movl %[next_sp],%%esp\n\t”    /<em> restore ESP   </em>/<br>　　进程切换的时候，要修改堆栈，eip等数据．在switch_to中完成了这个工作。<br>　　(３)保存eip的值<br>　　“movl $1f,%[prev_ip]\n\t” /<em> save    EIP   </em>/ \<br>　　“pushl %[next_ip]\n\t” /<em> restore EIP   </em>/ \<br>　　将标号1:的地址保存到prev-&gt;thread.ip中，然后下一次该进程被调用的时候，就从１的位置开始执行。<br>　　注明：如果之前next也被switch_to出去过，那么next-&gt;thread.ip里存的就是下面这个1f的标号，但如果next进程刚刚被创建，之前没有被switch_to出去过，那么next-&gt;thread.ip里存的将是ret_ftom_fork，即进程刚刚被fork后执行exec．<br>　　(4)jmp <strong>switch_to<br>　　让参数不压入堆栈，而是使用寄存器传值，来调用</strong>switch_to eax存放prev,edx存放next。</p><p>#二.gdb跟踪schedule函数<br><img src="http://img.blog.csdn.net/20150426150532300" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20150426150508441" alt="这里写图片描述"></p><hr><p>小结：整个schedule的执行过程如下图所示<br>　|———————————-|<br>　schedule<br>  　　sched_submit_work(tsk)<br>  　　_schedule()<br>  　　　　pick_next_task<br>  　　　　context_switch(rq,prev,next)<br>  　　　　　　prepare_task_switch<br>  　　　　　　判断是不是内核线程<br>  　　　　　　switch_mm<br>  　　　　　　switch_to<br>  　　　　　　　　_switch_to<br>  　　　　　　finish_task_switch</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;　　Linux内核课第八周作业。本文在云课堂中实验楼完成。&lt;br&gt;　　唐国泽 原创作品转载请注明出处 《Linux内核分析》MOOC课程&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com//blog/2016/06/06/Test%20UNIX%20United%20system%20%E5%88%86%E6%9E%90.md.html"/>
    <id>http://yoursite.com//blog/2016/06/06/Test UNIX United system 分析.md.html</id>
    <published>2016-06-06T04:00:00.000Z</published>
    <updated>2018-05-08T03:01:20.202Z</updated>
    
    <content type="html"><![CDATA[<hr><hr><p></p><p>唐国泽 原创作品转载请注明出处 《Linux内核分析》MOOC课程<a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="noopener">http://mooc.study.163.com/course/USTC-1000029000</a></p><p></p><p></p><p>UNIX操作系统，是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统</p><p></p><blockquote><br><p>UNIX  United  is  an  architecture  for  a  distributed  system  based  on UNIX.<br><br>UNIX United可以看做是一种多台UNIX组成分布式系统的解决方案。</p><br></blockquote><br><h1 id="introduction">1.Introduction</h1><br><p>UNIX United系统是通过将一组的UNIX系统计算机，在上层叠加一个系统方式，是值在操作的时候，完全隐藏所有的处理器通信和网络协议。并且所有的UNUX工作方式（如：设备保护，访问和文件访问，进程间通信，输入/输出，重定向）都是一样的，和独立的UNIX没有任何差别。</p><br><blockquote><br><p>参考文献：<br><br>《The Newcastle Connection or UNIXes of the world Unite!》<br><br>《The Architecture of UNIX United》</p><br></blockquote><br><p><strong>疑问：对文件访问的控制是怎么处理的呢？</strong></p><br><h1 id="对文件访问的处理">2.对文件访问的处理</h1><br><p><img src="http://img.blog.csdn.net/20150427221713582" alt="这里写图片描述"></p><br><p>简单的举一个例子，我们有两个独立的UNIX系统主机，现在将其构建成UNIX United System, 构建之后，UNIX1的用户如何读取UNIX2的文件呢？<br><br>　　<img src="http://img.blog.csdn.net/20150427221836262" alt="这里写图片描述"><br><br>　　不知道大家是否还记得: <strong>“ / ” 表示根目录，“</strong> … ”表示当前目录的上一层目录，那么问题来了，“ /…  ”表示什么呢？</p><br><blockquote><br><p>如果在UNIX１主机上复制文件a到UNIX２上，可以这样操作。<br><br>cp  /user/brian/a   /…/unix2/user/brian/a<br><br>现在问题再一次出现，这个cp使用的是UNIX1中的cp还是UNIX2中的cp呢？</p><br></blockquote><br><h1 id="３.用户认证和访问权限控制">３.用户认证和访问权限控制</h1><br><p>UNIX中用户认证相关的文件：用户，组，用户密码，Root<br><br>UNIX United System中，各个子UNIX System拥有自己独立的users,user groups and user password file,root; 但每个系统都有义务对要登录UNIX United System的用户进行认证，那怎么认证呢？<br><br>比如机器A上的用户u, 我们记为“A/u”，身份认证由A完成，但用户u可以访问所有A和B上属于该用户的文件。</p><br><h1 id="连接通信-远程文件访问的处理">4.连接通信-远程文件访问的处理</h1><br><p><img src="http://img.blog.csdn.net/20150427221907760" alt="这里写图片描述"></p><br><p>在原有UNIX的基础上添加了一个通信链路和一个软件层, 这两部分的位置在UNIX Kernel和UNIX software之间。Newcastle Connection相当于是一个“过滤器”，过滤出要重定向其他系统的系统调用，而UNIX1和UNIX2之间的通信是通过远程过程调用(Remote Procedure Call，RPC)来交流的。<br><br>　　<img src="http://img.blog.csdn.net/20150427222109033" alt="这里写图片描述"></p><br><blockquote><br><p>流程如下所示：</p><br><ol><br><li>上层应用发出一个系统调用；</li><br><li>Newcastle Connection检测该系统调用是不是远程调用；不是远程调用则直接转换为本地的系统调用（内核服务）；如果是对远程的文件进程操作，则是远程调用。</li><br><li>远程调用，则通过连接层将命令(加上额外信息，如当前用户id)发送到远程主机上（连接层相当于管道，连接了UNIX1和UNIX2）;</li><br><li>连接层解析文件的名称（如： /…/UNIX2/）将其传递给对应的计算机。</li><br><li>远程主机调用对应进程来处理（即UNIX United中只有本地操作），远程主机返回执行情况</li><br></ol><br></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;&lt;/p&gt;&lt;p&gt;唐国泽 原创作品转载请注明出处 《Linux内核分析》MOOC课程&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com//blog/2016/06/06/UNIX%20United%20system%20%E5%88%86%E6%9E%90.html"/>
    <id>http://yoursite.com//blog/2016/06/06/UNIX United system 分析.html</id>
    <published>2016-06-06T04:00:00.000Z</published>
    <updated>2018-05-08T03:01:20.202Z</updated>
    
    <content type="html"><![CDATA[<p>唐国泽 原创作品转载请注明出处 《Linux内核分析》MOOC课程<a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="noopener">http://mooc.study.163.com/course/USTC-1000029000</a></p><p>UNIX操作系统，是一个强大的多用户、多任务操作系统，支持多种处理器架构，按照操作系统的分类，属于分时操作系统</p><blockquote><p>UNIX  United  is  an  architecture  for  a  distributed  system  based  on UNIX.<br>UNIX United可以看做是一种多台UNIX组成分布式系统的解决方案。</p></blockquote><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h1><p>UNIX United系统是通过将一组的UNIX系统计算机，在上层叠加一个系统方式，是值在操作的时候，完全隐藏所有的处理器通信和网络协议。并且所有的UNUX工作方式（如：设备保护，访问和文件访问，进程间通信，输入/输出，重定向）都是一样的，和独立的UNIX没有任何差别。</p><blockquote><p>参考文献：<br>《The Newcastle Connection or UNIXes of the world Unite!》<br>《The Architecture of UNIX United》</p></blockquote><p><strong>疑问：对文件访问的控制是怎么处理的呢？</strong></p><h1 id="2-对文件访问的处理"><a href="#2-对文件访问的处理" class="headerlink" title="2.对文件访问的处理"></a>2.对文件访问的处理</h1><p>　　<img src="http://img.blog.csdn.net/20150427221713582" alt="这里写图片描述"></p><p>简单的举一个例子，我们有两个独立的UNIX系统主机，现在将其构建成UNIX United System, 构建之后，UNIX1的用户如何读取UNIX2的文件呢？<br>　　<img src="http://img.blog.csdn.net/20150427221836262" alt="这里写图片描述"><br>　　不知道大家是否还记得: <strong>“ / ” 表示根目录，“</strong> .. ”表示当前目录的上一层目录，那么问题来了，“ /..  ”表示什么呢？</p><blockquote><p>如果在UNIX１主机上复制文件a到UNIX２上，可以这样操作。<br>cp  /user/brian/a   /../unix2/user/brian/a<br>现在问题再一次出现，这个cp使用的是UNIX1中的cp还是UNIX2中的cp呢？</p></blockquote><h1 id="３-用户认证和访问权限控制"><a href="#３-用户认证和访问权限控制" class="headerlink" title="３.用户认证和访问权限控制"></a>３.用户认证和访问权限控制</h1><p>UNIX中用户认证相关的文件：用户，组，用户密码，Root<br>UNIX United System中，各个子UNIX System拥有自己独立的users,user groups and user password file,root; 但每个系统都有义务对要登录UNIX United System的用户进行认证，那怎么认证呢？<br>比如机器A上的用户u, 我们记为“A/u”，身份认证由A完成，但用户u可以访问所有A和B上属于该用户的文件。</p><h1 id="4-连接通信-远程文件访问的处理"><a href="#4-连接通信-远程文件访问的处理" class="headerlink" title="4.连接通信-远程文件访问的处理"></a>4.连接通信-远程文件访问的处理</h1><p>　　<img src="http://img.blog.csdn.net/20150427221907760" alt="这里写图片描述"></p><p>在原有UNIX的基础上添加了一个通信链路和一个软件层, 这两部分的位置在UNIX Kernel和UNIX software之间。Newcastle Connection相当于是一个“过滤器”，过滤出要重定向其他系统的系统调用，而UNIX1和UNIX2之间的通信是通过远程过程调用(Remote Procedure Call，RPC)来交流的。<br>　　<img src="http://img.blog.csdn.net/20150427222109033" alt="这里写图片描述"></p><blockquote><p>流程如下所示：</p><ol><li>上层应用发出一个系统调用；</li><li>Newcastle Connection检测该系统调用是不是远程调用；不是远程调用则直接转换为本地的系统调用（内核服务）；如果是对远程的文件进程操作，则是远程调用。</li><li>远程调用，则通过连接层将命令(加上额外信息，如当前用户id)发送到远程主机上（连接层相当于管道，连接了UNIX1和UNIX2）;</li><li>连接层解析文件的名称（如： /../UNIX2/）将其传递给对应的计算机。</li><li>远程主机调用对应进程来处理（即UNIX United中只有本地操作），远程主机返回执行情况</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;唐国泽 原创作品转载请注明出处 《Linux内核分析》MOOC课程&lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://mooc.st
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com//blog/2015/07/13/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B6_%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA.html"/>
    <id>http://yoursite.com//blog/2015/07/13/Linux内核分析课程6_进程创建.html</id>
    <published>2015-07-13T04:00:00.000Z</published>
    <updated>2018-05-08T03:51:40.906Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Linux内核课第六周作业。本文在云课堂中实验楼完成。<br>唐国泽 原创作品转载请注明出处 <a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="noopener">《Linux内核分析》MOOC课程</a></p></blockquote><p>#一.fork()系统调用<br><strong>预备知识</strong>：这里先列出一些必要的预备知识，对linux下进程机制比较熟悉的朋友可以略过。  </p><ol><li>进程可以看做程序的一次执行过程。在linux下，每个进程有唯一的PID标识进程。PID是一个从1到32768的正整数，其中1一般是特殊进程init，其它进程从2开始依次编号。当用完32768后，从2重新开始。  </li><li>linux中有一个叫进程表的结构用来存储当前正在运行的进程。可以使用“ps aux”命令查看所有正在运行的进程。  </li><li>进程在linux中呈树状结构，init为根节点，其它进程均有父进程，某进程的父进程就是启动这个进程的进程，这个进程叫做父进程的子进程。  <blockquote><p><a href="http://www.cnblogs.com/leoo2sk/archive/2009/12/11/talk-about-fork-in-linux.html" target="_blank" rel="noopener">上述摘自:[从一道面试题谈linux下fork的运行机制]</a>      </p></blockquote></li></ol><p>下面分析一个简单的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int main(int argc, char * argv[])</span><br><span class="line">&#123;</span><br><span class="line">    int pid;</span><br><span class="line">    /* fork another process */</span><br><span class="line">    pid = fork();</span><br><span class="line">    if (pid &lt; 0) </span><br><span class="line">    &#123; </span><br><span class="line">        /* error occurred */</span><br><span class="line">        fprintf(stderr,&quot;Fork Failed!&quot;);</span><br><span class="line">        exit(-1);</span><br><span class="line">    &#125; </span><br><span class="line">    else if (pid == 0) </span><br><span class="line">    &#123;</span><br><span class="line">        /* child process */</span><br><span class="line">        printf(&quot;This is Child Process!\n&quot;);</span><br><span class="line">    &#125; </span><br><span class="line">    else </span><br><span class="line">    &#123;  </span><br><span class="line">        /* parent process  */</span><br><span class="line">        printf(&quot;This is Parent Process!\n&quot;);</span><br><span class="line">        /* parent will wait for the child to complete*/</span><br><span class="line">        wait(NULL);</span><br><span class="line">        printf(&quot;Child Complete!\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>   &#160; &#160; 比较简单,运行结果为:<br>  &#160; &#160;  This is Child Process!<br>  &#160; &#160;  This is Parent Process!<br> &#160; &#160; Child Complete!<br>   &#160; &#160; <strong>在pid = fork()前,只有一个进程执行这段代码,但在这条语句滞后,就有两个进程在执行后面的代码了,接下来的代码是if(pid…..)</strong><br>  &#160; &#160;  补充: fork语句的返回值<br>   &#160; &#160; fork系统调用调用一次, 返回两次, 在这里有可能有三种返回值<br>  &#160; &#160;   1）在父进程中，<strong>fork返回新创建子进程的进程ID；</strong><br>  &#160; &#160;   2）在子进程中，fork返回0；<br>&#160; &#160;     3）如果出现错误，fork返回一个负值；<br>  &#160; &#160;   所有在这段代码中, 如果pid = fork()执行成功, 那就有两个进程了, 一个父进程和一个子进程, 在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。<br>   &#160; &#160;   fork出错可能有两种原因：<br>  &#160; &#160;1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。<br> &#160; &#160; 2）系统内存不足，这时errno的值被设置为ENOMEM。<br>  &#160; &#160;   创建新进程成功后，系统中出现两个基本完全相同的进程，<strong>这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略</strong>。<br>    参考博文:<a href="http://blog.csdn.net/jason314/article/details/5640969" target="_blank" rel="noopener">linux中fork（）函数详解（原创！！实例讲解）</a></p><hr><p>#二.fork对应的系统调用过程<br> &#160; &#160; 在 Linux 内核中,供用户创建进程的系统调用fork()函数的响应函数是 sys_fork()、sys_clone()、sys_vfork()。这三个函数<strong>都是通过调用内核函数 do_fork() 来实现的</strong>。根据调用时所使用的 clone_flags 参数不同，do_fork() 函数完成的工作也各异。<br>  &#160; &#160;  下面分析do_fork(), 该函数主要作用是复制原来的进程成为另一个新的进程，它完成了整个进程的创建过程。<br>   &#160; &#160; 先了解do_fork()函数的几个参数:<br>  &#160; &#160;  clone_flags：该标志位的4个字节分为两部分。最低的一个字节为子进程结束时发送给父进程的信号代码，通常为SIGCHLD；剩余的三个字节则是各种clone标志的组合。通过clone标志可以有选择的对父进程的资源进行复制。例如CLONE_VM表示共享内存描述符合所有的页表； CLONE_FS共享根目录和当前工作目录所在的表以及权限掩码。<br>&#160; &#160; statck_start：子进程用户态堆栈的地址；<br>&#160; &#160; regs：指向pt_regs结构体的指针。当系统发生系统调用，即用户进程从用户态切换到内核态时，该结构体保存通用寄存器中的值，并被存放于内核态的堆栈中；<br>&#160; &#160; stack_size：未被使用，通常被赋值为0；<br>&#160; parent_tidptr：父进程在用户态下pid的地址，该参数在CLONE_PARENT_SETTID标志被设定时有意义；<br>&#160; &#160; child_tidptr：子进程在用户态下pid的地址，该参数在CLONE_CHILD_SETTID标志被设定时有意义。</p><p>&#160; &#160; do_fork() 函数生成一个新的进程，大致分为三个步骤:<br>&#160; &#160; 1)建立进程控制结构并赋初值，使其成为进程映像。这个过程完成以下内容。<br>       &#160; &#160; (1) 在内存中分配一个 task_struct 数据结构，以代表即将产生的新进程。<br>       &#160; &#160; (2)把父进程 PCB 的内容复制到新进程的 PCB 中。<br>       &#160; &#160; (3)<strong>为新进程分配一个唯一的进程标识号 PID 和 user_struct 结构。</strong>然后检查用户具有执行一个新进程所必须具有的资源。<br>       &#160; &#160; (4)重新设置 task_struct 结构中那些与父进程值不同的数据成员。<br>       &#160; &#160;(5)设置进程管理信息，根据所提供的 clone_flags 参数值，决定是否对父进程 task_struct 中的指针 fs 、files 指针等所选择的部分进行拷贝，如果 clone_flags 参数指明的是共享而不是拷贝，则将其计数器 count 的值加 1 ，否则就拷贝新进程所需要的相关信息内容 PCB 。这个地方是区分 sys_fork() 还是 sys_clone() 。</p><p>   &#160; &#160; 2) 必须为新进程的执行设置跟踪进程执行情况的相关内核数据结构。包括 任务数组、自由时间列表 tarray_freelist 以及 pidhash[] 数组。这部分完成如下内容：<br>       &#160; &#160; (1) 把新进程加入到进程链表中<br>     &#160; &#160;   (2) 把新进程加入到 pidhash 散列表中，并增加任务计数值。<br>  &#160; &#160;      (3) 通过拷贝父进程的上、下文来初始化硬件的上下文（TSS段、LDT以及 GDT）。</p><p>  &#160; &#160;  3) 启动调度程序，使子进程获得运行的机会。<br>        &#160; &#160;  这部分完成以下动作：<br> &#160; &#160;   (1) 设置新的就绪队列状态 TASK_RUNING , 并将新进程挂到就绪队列中，并重新启动调度程序使其运行。<br>&#160; &#160;    (2) 向父进程返回子进程的 PID，设置子进程从 do_fork() 返回 0 值。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int do_fork(unsigned long clone_flags,unsigned long stack_start, struct pt_regs *regs,</span><br><span class="line">                unsigned long stack_size)</span><br><span class="line">&#123;</span><br><span class="line">        int                   retval;</span><br><span class="line">        struct  task_struct   *p;</span><br><span class="line">        struct  completion    vfork;</span><br><span class="line"></span><br><span class="line">       retval = -EPERM ;</span><br><span class="line"></span><br><span class="line">       if ( clone_flags &amp; CLONE_PID )</span><br><span class="line">       &#123;</span><br><span class="line">             if ( current-&gt;pid )</span><br><span class="line">                     goto fork_out;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       reval = -ENOMEM ;</span><br><span class="line">       </span><br><span class="line">       p = alloc_task_struct();    // 分配内存建立新进程的 task_struct 结构</span><br><span class="line">       if ( !p )</span><br><span class="line">              goto fork_out;</span><br><span class="line"></span><br><span class="line">       *p = *current ;  //将当前进程的 task_struct 结构的内容复制给新进程的 PCB结构</span><br><span class="line"></span><br><span class="line">       retval = -EAGAIN;</span><br><span class="line"></span><br><span class="line">       //下面代码对父、子进程 task_struct 结构中不同值的数据成员进行赋值</span><br><span class="line"></span><br><span class="line">       if ( atomic_read ( &amp;p-&gt;user-&gt;processes ) &gt;= p-&gt;rlim[RLIMIT_NPROC].rlim_cur</span><br><span class="line">               &amp;&amp; !capable( CAP_SYS_ADMIN ) &amp;&amp; !capable( CAP_SYS_RESOURCE ))</span><br><span class="line">               goto bad_fork_free;</span><br><span class="line"></span><br><span class="line">       atomic_inc ( &amp;p-&gt;user-&gt;__count);   //count 计数器加 1</span><br><span class="line">       atomic_inc ( &amp;p-&gt;user-&gt;processes); //进程数加 1</span><br><span class="line"></span><br><span class="line">       if ( nr_threads &gt;= max_threads )</span><br><span class="line">              goto bad_fork_cleanup_count ;</span><br><span class="line"></span><br><span class="line">       get_exec_domain( p-&gt;exec_domain );</span><br><span class="line"></span><br><span class="line">       if ( p-&gt;binfmt &amp;&amp; p-&gt;binfmt-&gt;module )</span><br><span class="line">                 __MOD_INC_USE_COUNT( p-&gt;binfmt-&gt;module ); //可执行文件 binfmt 结构共享计数 + 1 </span><br><span class="line">       p-&gt;did_exec = 0 ;                                   //进程未执行</span><br><span class="line">       p-&gt;swappable = 0 ;                                  //进程不可换出</span><br><span class="line">       p-&gt;state = TASK_UNINTERRUPTIBLE ;                   //置进程状态</span><br><span class="line">       copy_flags( clone_flags,p );                        //拷贝进程标志位</span><br><span class="line">       p-&gt;pid = get_pid( clone_flags );                    //为新进程分配进程标志号</span><br><span class="line">       p-&gt;run_list.next = NULL ;</span><br><span class="line">       p-&gt;run_list.prev = NULL ;</span><br><span class="line">       p-&gt;run_list.cptr = NULL ;</span><br><span class="line"></span><br><span class="line">       init_waitqueue_head( &amp;p-&gt;wait_childexit );          //初始化 wait_childexit 队列</span><br><span class="line"></span><br><span class="line">       p-&gt;vfork_done  = NULL ;</span><br><span class="line"></span><br><span class="line">       if ( clone_flags &amp; CLONE_VFORK ) &#123;</span><br><span class="line">              p-&gt;vfork_done = &amp;vfork ; </span><br><span class="line">              init_completion(&amp;vfork) ;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       spin_lock_init( &amp;p-&gt;alloc_lock );</span><br><span class="line"></span><br><span class="line">       p-&gt;sigpending = 0 ;</span><br><span class="line"></span><br><span class="line">       init_sigpending( &amp;p-&gt;pending );</span><br><span class="line">       p-&gt;it_real_value = p-&gt;it_virt_value = p-&gt;it_prof_value = 0 ; //初始化时间数据成员</span><br><span class="line">       p-&gt;it_real_incr = p-&gt;it_virt_incr = p-&gt;it_prof_incr = 0 ;    //初始化定时器结构</span><br><span class="line">       init_timer( &amp;p-&gt;real_timer );</span><br><span class="line">       p-&gt;real_timer.data = (unsigned long)p;</span><br><span class="line">       p-&gt;leader = 0 ;</span><br><span class="line">       p-&gt;tty_old_pgrp = 0 ;</span><br><span class="line">       p-&gt;times.tms_utime = p-&gt;times.tms_stime = 0 ;                 //初始化进程的各种运行时间</span><br><span class="line">       p-&gt;times.tms_cutime = p-&gt;times.tms_cstime = 0 ;</span><br><span class="line">#ifdef CONFIG_SMP                 //初始化对称处理器成员</span><br><span class="line">   &#123;</span><br><span class="line">        int      i;</span><br><span class="line">        p-&gt;cpus_runnable = ~0UL;</span><br><span class="line">        p-&gt;processor = current-&gt;processor ;</span><br><span class="line">        for( i = 0 ; i &lt; smp_num_cpus ; i++ )</span><br><span class="line">                 p-&gt;per_cpu_utime[ i ] = p-&gt;per_cpu_stime[ i ] = 0;</span><br><span class="line">        spin_lock_init ( &amp;p-&gt;sigmask_lock );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">#endif</span><br><span class="line">       p-&gt;lock_depth = -1 ;        // 注意：这里 -1 代表 no ,表示在上下文切换时，内核不上锁</span><br><span class="line">       p-&gt;start_time = jiffies ;   // 设置进程的起始时间</span><br><span class="line"></span><br><span class="line">       INIT_LIST_HEAD ( &amp;p-&gt;local_pages );</span><br><span class="line">       retval = -ENOMEM ;</span><br><span class="line"></span><br><span class="line">       if ( copy_files ( clone_flags , p ))      //拷贝父进程的 files 指针，共享父进程已打开的文件</span><br><span class="line">               goto bad_fork_cleanup ;</span><br><span class="line"></span><br><span class="line">       if ( copy_fs ( clone_flags , p ))         //拷贝父进程的 fs 指针，共享父进程文件系统</span><br><span class="line">               goto bad_fork_cleanup_files ;</span><br><span class="line"></span><br><span class="line">       if ( copy_sighand ( clone_flags , p ))    //子进程共享父进程的信号处理函数指针</span><br><span class="line">               goto bad_fork_cleanup_fs ;</span><br><span class="line"></span><br><span class="line">       if ( copy_mm ( clone_flags , p ))</span><br><span class="line">               goto bad_fork_cleanup_mm ;        //拷贝父进程的 mm 信息，共享存储管理信息</span><br><span class="line"></span><br><span class="line">       retval = copy_thread( 0 , clone_flags , stack_start, stack_size , p regs );</span><br><span class="line">                                                 //初始化 TSS、LDT以及GDT项</span><br><span class="line"></span><br><span class="line">       if ( retval )</span><br><span class="line">               goto bad_fork_cleanup_mm ;</span><br><span class="line"></span><br><span class="line">       p-&gt;semundo = NULL ;                       //初始化信号量成员</span><br><span class="line"></span><br><span class="line">       p-&gt;prent_exec_id = p-self_exec_id ;</span><br><span class="line"></span><br><span class="line">       p-&gt;swappable = 1 ;                        //进程占用的内存页面可换出</span><br><span class="line"></span><br><span class="line">       p-&gt;exit_signal = clone_flag &amp; CSIGNAL ;</span><br><span class="line"></span><br><span class="line">       p-&gt;pdeatch_signal = 0 ;                   //注意：这里是父进程消亡后发送的信号</span><br><span class="line"></span><br><span class="line">       p-&gt;counter = (current-&gt;counter + 1) &gt;&gt; 1 ;//进程动态优先级，这里设置成父进程的一半,应注意的是，这里是采用位操作来实现的。</span><br><span class="line"></span><br><span class="line">       current-&gt;counter &gt;&gt; =1;</span><br><span class="line"></span><br><span class="line">       if ( !current-&gt;counter )</span><br><span class="line">               current-&gt;need_resched = 1 ;        //置位重新调度标记，实际上从这个地方开始，分裂成了父子两个进程。</span><br><span class="line">       </span><br><span class="line">       retval = p-&gt;pid ;</span><br><span class="line"></span><br><span class="line">       p-&gt;tpid = retval ;</span><br><span class="line">       INIT_LIST_HEAD( &amp;p-&gt;thread_group );</span><br><span class="line"></span><br><span class="line">       write_lock_irq( &amp;tasklist_lock );</span><br><span class="line"></span><br><span class="line">       p-&gt;p_opptr = current-&gt;p_opptr ;</span><br><span class="line">       p-&gt;p_pptr = current-&gt;p_pptr ;</span><br><span class="line"></span><br><span class="line">       if ( !( clone_flags &amp; (CLONE_PARENT | CLONE_THREAD ))) &#123;</span><br><span class="line">                p-&gt;opptr = current ;</span><br><span class="line">                if ( !(p-&gt;ptrace &amp; PT_PTRACED) )</span><br><span class="line">                        p-&gt;p_pptr = current ;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if ( clone_flags &amp; CLONE_THREAD )&#123;</span><br><span class="line">                p-&gt;tpid = current-&gt;tpid ;</span><br><span class="line">                list_add ( &amp;p-&gt;thread_group,&amp;current-&gt;thread_group );</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       SET_LINKS(p);</span><br><span class="line"></span><br><span class="line">       hash_pid(p);</span><br><span class="line">       nr_threads++;</span><br><span class="line"></span><br><span class="line">       write_unlock_irq( &amp;tasklist_lock );</span><br><span class="line">       if ( p-&gt;ptrace &amp; PT_PTRACED )</span><br><span class="line">                 send_sig( SIGSTOP , p ,1 );</span><br><span class="line">       wake_up_process(p);        //把新进程加入运行队列，并启动调度程序重新调度，使新进程获得运行机会</span><br><span class="line">       ++total_forks ; </span><br><span class="line">       if ( clone_flags &amp; CLONE_VFRK )</span><br><span class="line">                 wait_for_completion(&amp;vfork);</span><br><span class="line"></span><br><span class="line">       //以下是出错处理部分</span><br><span class="line">       fork_out:</span><br><span class="line">                 return retval;</span><br><span class="line">       bad_fork_cleanup_mm:</span><br><span class="line">                 exit_mm(p);</span><br><span class="line">       bad_fork_cleanup_sighand:</span><br><span class="line">                 exit_sighand(p);</span><br><span class="line">       bad_fork_cleanup_fs:</span><br><span class="line">                 exit_fs(p);</span><br><span class="line">       bad_fork_cleanup_files:</span><br><span class="line">                 exit_files(p);</span><br><span class="line"></span><br><span class="line">       bad_fork_cleanup:</span><br><span class="line">                 put_exec_domain( p-&gt;exec_domain );</span><br><span class="line"></span><br><span class="line">                 if ( p-&gt;binfmt &amp;&amp; p-&gt;binfmt-&gt;module )</span><br><span class="line">                               __MOD_DEC_USE_COUNT( p-&gt;binfmt-&gt;module );</span><br><span class="line">       bad_fork_cleanup_count:</span><br><span class="line">                 atomic_dec( &amp;p-&gt;user-&gt;processes );</span><br><span class="line">                 free_uid ( p-&gt;user );</span><br><span class="line">       bad_fork_free:</span><br><span class="line">                 free_task_struct(p);</span><br><span class="line">                 goto fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#三.实验<br>&#160; &#160;    实验是在实验楼完成的:<br>   <img src="http://img.blog.csdn.net/20150412211133964" alt="这里写图片描述"></p><p>&#160; &#160; 总结:<br>&#160; &#160; 1.新进程的执行起点为: ret_form_fork<br>&#160; &#160; 当他从ret_from_fork退出时，会从堆栈中弹出原来保存的eip，而ip指向kernel_thread_helper, </p><p>&#160; &#160; 至此kernel_thread_helper被调用，他就能够运行我们的指定的函数了do_exit().<br>&#160; &#160; do_fork的执行流程可如下图表示:<br><img src="http://img.blog.csdn.net/20150412205951386" alt="这里写图片描述"><br>图摘自:<a href="http://www.ahlinux.com/start/base/6893.html" target="_blank" rel="noopener">Linux进程切换</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Linux内核课第六周作业。本文在云课堂中实验楼完成。&lt;br&gt;唐国泽 原创作品转载请注明出处 &lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; re
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com//blog/2015/04/23/Linux%E5%86%85%E6%A0%B8%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B8_%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E4%B8%8E%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%20(1).html"/>
    <id>http://yoursite.com//blog/2015/04/23/Linux内核分析课程8_进程调度与进程切换过程 (1).html</id>
    <published>2015-04-23T04:00:00.000Z</published>
    <updated>2018-05-09T02:43:25.479Z</updated>
    
    <content type="html"><![CDATA[<p>Linux内核课第八周作业。本文在云课堂中实验楼完成。<br>唐国泽 原创作品转载请注明出处 <a href="http://mooc.study.163.com/course/USTC-1000029000" target="_blank" rel="noopener">《Linux内核分析》MOOC课程</a>  </p><hr><h1 id="一-schedule-函数介绍"><a href="#一-schedule-函数介绍" class="headerlink" title="一.schedule()函数介绍"></a>一.schedule()函数介绍</h1><h2 id="１-进程调度的时机"><a href="#１-进程调度的时机" class="headerlink" title="１.进程调度的时机"></a>１.进程调度的时机</h2><p>　　中断处理过程（包括<strong>时钟中断、I/O中断、系统调用和异常</strong>）中，直接调用schedule()，或者返回用户态时根据need_resched标记调用schedule()；<br>　　<strong>内核线程</strong>可以<strong>直接</strong>调用<strong>schedule()</strong>进行进程切换，也可以在中断处理过程中进行调度，也就是说内核线程作为一类的特殊的进程可以主动调度，也可以被动调度；<br>　　<strong>用户态进程无法实现主动调度，仅能通过陷入内核态后的某个时机点进行调度</strong>，即在中断处理过程中进行调度。</p><h2 id="2-进程的切换"><a href="#2-进程的切换" class="headerlink" title="2.进程的切换"></a>2.进程的切换</h2><p>　　为了控制进程的执行，内核必须有能力挂起正在CPU上执行的进程，并恢复以前挂起的某个进程的执行，这叫做进程切换、任务切换、上下文切换；<br>　　挂起正在CPU上执行的进程，与中断时保存现场是不同的，中断前后是在同一个进程上下文中，只是由用户态转向内核态执行；<br>　　进程上下文包含了进程执行需要的所有信息：<br>　　- 用户地址空间：包括程序代码，数据，用户堆栈等<br>　　- 控制信息：进程描述符，内核堆栈等<br>　　- 硬件上下文（注意中断也要保存硬件上下文只是保存的方法不同）</p><h2 id="3-具体进程切换的代码分析"><a href="#3-具体进程切换的代码分析" class="headerlink" title="3.具体进程切换的代码分析"></a>3.具体进程切换的代码分析</h2><p>　　<strong>schedule()函数</strong>选择一个新的进程来运行，并调用<strong>context_switch</strong>进行上下文的切换，这个<strong>宏调用switch_to</strong>来进行关键上下文切换：<br>　　主要调用过程：  </p><p><pre><br>　　　　next = pick_next_task(rq, prev);//进程调度算法都封装这个函数内部<br>　　　　context_switch(rq, prev, next);//进程上下文切换<br></pre><br>　　switch_to利用了prev和next两个参数：prev指向当前进程，next指向被调度的进程</p><h3 id="1-schedule-函数"><a href="#1-schedule-函数" class="headerlink" title="1)schedule()函数"></a>1)schedule()函数</h3><p>　　首先，切换时候，调用call schedule()；来执行schedule（）函数，如下图所示：<br>　　<img src="http://img.blog.csdn.net/20150426132041286" alt="这里写图片描述"><br>　　使用struct task_struct *tsk = current; 来获取当前进程；sched_submit_work(tsk);  避免死锁；最后调用＿schedule()来处理切换过程</p><h3 id="２-＿schedule-函数"><a href="#２-＿schedule-函数" class="headerlink" title="２)＿schedule()函数"></a>２)＿schedule()函数</h3><p>　　<img src="http://img.blog.csdn.net/20150426132355288" alt="这里写图片描述"><br>　　其中 need_resched:为切换前的变量准备：<br>　　　　preempt_disable()；//禁止内核抢占；<br>　　　　cpu = smp_processor_id(); //获取当前CPU<br>　　　　rq = cpu_rq(cpu);    //获取该CPU维护的运行队列（run queue)<br>　　　　rcu_note_context_switch(cpu);  //更新全局状态，标识当前CPU发生上下文的切换<br>　　　　prev = rq-&gt;curr;    //运行队列中的curr指针赋予prev。</p><p>　　<img src="http://img.blog.csdn.net/20150426132741339" alt="这里写图片描述"><br>　　其中的next=pick_next_task(rq, prev)来确定使用哪一种进程调度的策略，但总是选择了下一个进程来进行切换，即根据调度策略选择一个优先级最高的任务将其定为下一个进程，最后都是调用context_switch来进行进程上下文的切换过程．</p><p>###３)context_switch函数解析<br>　　<img src="http://img.blog.csdn.net/20150426132853739" alt="这里写图片描述"><br>　　其中prepare_task_switch（）函数是完成切换前的准备工作；接着后面判断当前进程是不是内核线程，如果是内核线程，则不需要切换上下文<br>　　<img src="http://img.blog.csdn.net/20150426144441350" alt="这里写图片描述">　<br>　　接着调用switch_mm(),把虚拟内存从一个进程映射切换到新进程中<br>　　调用switch_to(),从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息<br>　　(１)如果next是内核线程，则线程使用prev所使用的地址空;schedule( )函数把该线程设置为懒惰TLB模式<br>　　事实上，每个内核线程并不拥有自己的页表集(task_struct-&gt;mm = NULL)；更确切地说，它使用一个普通进程的页表集。不过，没有必要使一个用户态线性地址对应的TLB表项无效，因为内核线程不访问用户态地址空间。<br><img src="http://img.blog.csdn.net/20150426145627173" alt="这里写图片描述"></p><p>　　(２)如果next是一个普通进程，schedule( )函数用next的地址空间替换prev的地址空间<br>　　|————————————–|<br>　　|   } else                             |<br>　　|       switch_mm(oldmm, mm, next);    |<br>　　|————————————–|</p><p>　　(３)如果prev是内核线程或正在退出的进程，context_switch()函数就把指向prev内存描述符的指针保存到运行队列的prev_mm字段中，然后重新设置prev-&gt;active_mm<br>　　<img src="http://img.blog.csdn.net/20150426145745626" alt="这里写图片描述"><br>　　context_switch()最后调用switch_to()执行prev和next之间的进程切换了<br>　　　　|———————————-|<br>　　　　|   switch_to(prev, next, prev);   |<br>　　　　|———————————-|<br>   　　　　 return prev;<br>　　　　}</p><p>###４)switch_to（）函数解析　<br>　　<img src="http://img.blog.csdn.net/20150426133034297" alt="这里写图片描述"><br>　　switch_to(prev, next, prev)：切换堆栈和寄存器的状态．<br>　　<img src="http://img.blog.csdn.net/20150426133255814" alt="这里写图片描述"><br>　　switch_to是一个宏定义，完成的工作主要是：<br>　　(1)保存当前进程的flags状态和当前进程的ebp<br>　　“pushfl\n\t”        /<em> save    flags </em>/<br>　　“pushl %%ebp\n\t”        /<em> save    EBP  </em>/<br>　　(2)完成内核堆在esp的切换<br>　　 “movl %%esp,%[prev_sp]\n\t”    /<em> save    ESP   </em>/<br>　　 “movl %[next_sp],%%esp\n\t”    /<em> restore ESP   </em>/<br>　　进程切换的时候，要修改堆栈，eip等数据．在switch_to中完成了这个工作。<br>　　(３)保存eip的值<br>　　“movl $1f,%[prev_ip]\n\t” /<em> save    EIP   </em>/ \<br>　　“pushl %[next_ip]\n\t” /<em> restore EIP   </em>/ \<br>　　将标号1:的地址保存到prev-&gt;thread.ip中，然后下一次该进程被调用的时候，就从１的位置开始执行。<br>　　注明：如果之前next也被switch_to出去过，那么next-&gt;thread.ip里存的就是下面这个1f的标号，但如果next进程刚刚被创建，之前没有被switch_to出去过，那么next-&gt;thread.ip里存的将是ret_ftom_fork，即进程刚刚被fork后执行exec．<br>　　(4)jmp <strong>switch_to<br>　　让参数不压入堆栈，而是使用寄存器传值，来调用</strong>switch_to eax存放prev,edx存放next。</p><p>#二.gdb跟踪schedule函数<br><img src="http://img.blog.csdn.net/20150426150532300" alt="这里写图片描述"></p><p><img src="http://img.blog.csdn.net/20150426150508441" alt="这里写图片描述"></p><hr><p>小结：整个schedule的执行过程如下图所示<br>　|———————————-|<br>　schedule<br>  　　sched_submit_work(tsk)<br>  　　_schedule()<br>  　　　　pick_next_task<br>  　　　　context_switch(rq,prev,next)<br>  　　　　　　prepare_task_switch<br>  　　　　　　判断是不是内核线程<br>  　　　　　　switch_mm<br>  　　　　　　switch_to<br>  　　　　　　　　_switch_to<br>  　　　　　　finish_task_switch</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Linux内核课第八周作业。本文在云课堂中实验楼完成。&lt;br&gt;唐国泽 原创作品转载请注明出处 &lt;a href=&quot;http://mooc.study.163.com/course/USTC-1000029000&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
